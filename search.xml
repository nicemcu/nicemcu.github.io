<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PSoC4 Uart Bootloader</title>
      <link href="/2022/11/20/PSoC4/PSoC4Bootloader/"/>
      <url>/2022/11/20/PSoC4/PSoC4Bootloader/</url>
      
        <content type="html"><![CDATA[<h3 id="PSoC4-Bootloader-and-Bootloadable"><a href="#PSoC4-Bootloader-and-Bootloadable" class="headerlink" title="PSoC4 Bootloader and Bootloadable"></a>PSoC4 Bootloader and Bootloadable</h3><p>参考文档：Infineon-<strong>AN68272</strong> - PSoC_4…_UART_Bootloader-ApplicationNotes-v16_00-EN.pdf</p><p>参考这篇文档很容易就可以实现PSoC uart的bootloader和bootloadable，So…这不是今天的主角，今天的主角是简单的、能看的懂的自实现的uart bootloader，并且可以引导运行bootloadable APP。</p><p>一、先简单过一遍官方的Bootloader和Bootloadable：</p><ol><li>实现： 实现过程很简单，只要分别在各自的工程中加入Bootloader和Bootloadable控件即可。</li><li>共享：Bootloader和Bootloadable共享变量：<strong>cyBtldrRunType</strong>。</li><li>从Btl跳转至App … 这有点复杂，所有相关操作均在Bootloader.c中，2900+行，兼容各种PSoC 3、4、5，读起来晦涩难懂，这就是为什么要自己实现个BTL，稍后再记录它吧。</li><li>从App跳转至Bootloader的实现：调用 Bootloadable_Load()  即可。</li></ol><pre class=" language-C"><code class="language-C">void Bootloadable_Load(void) {    /* Schedule Bootloader to start after reset */    Bootloadable_SET_RUN_TYPE(Bootloadable_SCHEDULE_BTLDR);    //Set cyBtldrRunType    CySoftwareReset();    //软复位}#define Bootloadable_SET_RUN_TYPE(x)        (cyBtldrRunType = (x))#define Bootloadable_SCHEDULE_BTLDB             (0x80u)#define Bootloadable_SCHEDULE_BTLDR             (0x40u)#define Bootloadable_SCHEDULE_MASK              (0xC0u)// Set cyBtldrRunType = Bootloadable_SCHEDULE_BTLDR;</code></pre><ol start="5"><li><p>Bootloadable生成的文件格式说明：参考<strong>AN68272</strong>  Append B，</p><ul><li><p>.elf ： 包含各种调试信息的文件。</p></li><li><p>.hex ：合并了bootloader、meta区的整个文件，可用于生产。</p></li><li><p>.cyacd：包含一个header line和诸多flash line，</p></li></ul><p><strong>Header line</strong>:  [4 Bytes Silicon ID] + [1Byte Silicon rev] + [1Byte checksum type]</p><p><strong>Flash line</strong>:  [1 Byte Array ID] + [2 Bytes row number] + [2Bytes data length] + [N Bytes data] + [1 Byte checksum] </p><p><strong>checksum type</strong>: 0 - 和校验，1 - CRC-16</p></li><li><p>Metadata: 位于flash最后一行的最后64字节，PSoC4的格式如下：</p></li></ol><pre class=" language-C"><code class="language-C">//metadata struct#pragma pack(1)                    //按字节对齐typedef struct{    uint8_t     appCheckSum;    //B0    uint32_t    appAddress;     //B1~B4    uint32_t    lastBtlRow;     //B5~B8    uint32_t    appLength;      //B9~B0C    uint8_t     NA1;            //B0D    uint8_t     NA2;            //B0E    uint8_t     NA3;            //B0F    uint8_t     appActive;      //B10    uint8_t     appVerified;    //B11    uint8_t     btlVersion;     //B12    uint16_t    appID;          //B13~B14    uint16_t    appVersion;     //B15~B16    uint16_t    appCustomID;    //B17~B18}strMetadata;       //__attribute__((aligned(1))) #pragma pack ()     </code></pre><ol start="7"><li>Bootloadable生成的.cyacd格式中，最后一行的flash data数据，就是如上的mata数据。其中：appLength、appCheckSum、appAddress等是bootloader用于校验app及跳转app的地址。</li><li>PSoC工程有如下几种类型，通过CYDEV_PROJ_TYPE定义工程类型。</li></ol><pre class=" language-C"><code class="language-C">#define CYDEV_PROJ_TYPE_STANDARD 0#define CYDEV_PROJ_TYPE_BOOTLOADER 1#define CYDEV_PROJ_TYPE_LOADABLE 2#define CYDEV_PROJ_TYPE_MULTIAPPBOOTLOADER 3#define CYDEV_PROJ_TYPE_LOADABLEANDBOOTLOADER 4#define CYDEV_PROJ_TYPE_LAUNCHER 5#define CYDEV_PROJ_TYPE 2</code></pre><p>二、手写一个 Uart Bootloader：</p><p>在之前的UART的工程上，增加协议、flash操作、跳转app前的校验及跳转函数即可。具体的请参考工程源码。下面是几点注意的地方：</p><ol><li><p>由于是普通工程（未包含Bootloader组件），所以CYDEV_PROJ_TYPE被定义为 CYDEV_PROJ_TYPE_STANDARD = 0。这个影响了cyBtldrRunType：普通工程中未定义该变量。如果CYDEV_PROJ_TYPE不为0，则会在Cm0plusStart.c中定义该变量。</p></li><li><p>App-Bootloadable的cm0plusgcc.ld连接文件中，将cyBtldrRunType链接至bootloaderruntype段：</p><pre class=" language-C"><code class="language-C">// Bootloadable - cm0plusgcc.ld__attribute__ ((section(".bootloaderruntype")))    volatile uint32 cyBtldrRunType;    .ramvectors (NOLOAD) : ALIGN(8)    {      __cy_region_start_ram = .;      KEEP(*(.ramvectors))    }    .btldr_run (NOLOAD) : ALIGN(8)    {        KEEP(*(.bootloaderruntype))    }    .noinit (NOLOAD) : ALIGN(8)    {      KEEP(*(.noinit))    }</code></pre><p>而普通工程中并没有 .btldr_run 段，ramvectors下接着就是noinit段。</p><pre class=" language-C"><code class="language-C">// CYDEV_PROJ_TYPE = CYDEV_PROJ_TYPE_STANDARD  - cm0plusgcc.ld       .ramvectors (NOLOAD) : ALIGN(8)    {      __cy_region_start_ram = .;      KEEP(*(.ramvectors))    }    .noinit (NOLOAD) : ALIGN(8)    {      KEEP(*(.noinit))    }</code></pre><p>尝试过在cm0plusgcc.ld中手动插入btldr_run段，clean &amp; rebuild后又被清掉，此路不通。</p><p>但是：可以定义一个变量cyBtldrRunTypeB放在noinit段中，查看并对比生成的map文件：</p><pre class=" language-C"><code class="language-C">// CYDEV_PROJ_TYPE = CYDEV_PROJ_TYPE_STANDARD  - cm0plusgcc.ld   CY_NOINIT volatile uint32_t cyBtldrRunTypeB; //CY_NOINIT 段是和Bootloadable段地址一样.noinit         0x200000b0        0x4 *(.noinit) .noinit        0x200000b0        0x4 .\CortexM0p\ARM_GCC_541\Debug\btl.o                0x200000b0                cyBtldrRunTypeB//Bootloadable    .btldr_run      0x200000b0        0x4 *(.bootloaderruntype) .bootloaderruntype                0x200000b0        0x4 .\CortexM0p\ARM_GCC_541\Debug\Cm0plusStart.o                0x200000b0                cyBtldrRunType    </code></pre><p>cyBtldrRunType 和 cyBtldrRunTypeB都位于0x200000b0地址。</p><p>这样在APP中调用Bootloadable_Load() 函数，会设置cyBtldrRunType = Bootloadable_SCHEDULE_BTLDR，软复位后进入自定义的Bootloader，通过访问相同地址的cyBtldrRunTypeB并判断是否为Bootloadable_SCHEDULE_BTLDR即可。</p></li></ol><ol start="3"><li><p>跳转：跳转参考官方Bootloader中实现：</p><pre class=" language-C"><code class="language-C">/* Moves argument appAddr (RO) into PC, moving execution to appAddr */#if defined (__ARMCC_VERSION)    __asm static void CustomBootloader_LaunchBootloadable(uint32 appAddr)    {        BX  R0        ALIGN    }#elif defined(__GNUC__)    __attribute__((noinline)) /* Workaround for GCC toolchain bug with inlining */    __attribute__((naked))    static void CustomBootloader_LaunchBootloadable(uint32 appAddr)    {        __asm volatile("    BX  R0\n");    }#elif defined (__ICCARM__)    static void CustomBootloader_LaunchBootloadable(uint32 appAddr)    {        __asm volatile("    BX  R0\n");    }#endif  /* (__ARMCC_VERSION) */CustomBootloader_LaunchBootloadable(meta->appAddress);     //校验通过 直接跳到APP区</code></pre><p>跳转地址需要注意：</p><p>CustomBootloader_LaunchBootloadable(<strong>meta-&gt;appAddress</strong>);     //校验通过 直接跳到APP区</p><p>跳转的地址不是设置的APP起始地址，而是meta区中存储的appAddress，比如在Bootloadable组件中，选择Manual application image placement: 0x00004000 , App从Flash 16KB地址开始，但是存储在<strong>meta-&gt;appAddress</strong>中的值并不是0x00004000 ，而是偏移了0x11个字节 - 0x4011，所以跳转必须要使用meta中存储的该地址。</p></li><li><p>跳转时需要使用<strong>meta-&gt;appAddress</strong>的值，但是校验APP的checksum时，需要从Manual application image placement地址开始，比如0x4000，长度为<strong>meta-&gt;appLength</strong>。</p><pre class=" language-C"><code class="language-C">uint8_t sum = 0;    uint8_t * p = (uint8_t *)STARTAPP_ADDR;    for(uint32_t i=0;i < meta->appLength; i++){    sum += p[i];}sum = ( uint8_t )1u + ( uint8_t )(~sum);if(sum != meta->appCheckSum)    return 6;</code></pre></li></ol><p>三、    PC APP</p><ol><li>官方提供了Bootloader Host软件，位于D:\Cypress\PSoC Creator\4.4\PSoC Creator\bin目录下，测试使用官方的Bootloader和Bootloadable组件，可以使用该软件测试bootloader.</li><li>同时也提供了相关的参考代码，位于： D:\Cypress\PSoC Creator\4.4\PSoC Creator\cybootloaderutils目录下。参考cybtldr_parse.c实现cyacd格式的解析。</li><li>UART协议未使用官方协议，改成我之前用过的简单协议，上位机在之前的串口程序中修改了一个，用于读取并解析.cyacd格式的app文件，并支持将app存储为纯BIN文件，方便使用其他工具升级。</li><li><strong>注：PC APP暂不支持中文路径。</strong></li></ol><p><img src="../../../../../medias/boardPic/2022/Infineon/P4PC.png" alt="PSoC4 Uart BTL PC APP"></p><p>可以看到如下信息：</p><p>Silicon ID：0x257C1175，校验和为普通SUM校验。</p><p>Flash Line信息：ROW Num64 ~ ROW Num72，为Flash Data。</p><p>ROW Num 511 ： MetaData。</p><p>串口调试信息：</p><p><img src="../../../../../medias/boardPic/2022/Infineon/P4BtlDbg.png" alt="PSoC4 Uart BTL DebugInfor"></p><ol><li>首次烧录Boot时，运行Bootloader程序。</li><li>通过PC更新过APP后，通过Reboot命令让Bootloader复位重启，运行APP程序。</li><li>可以看出appAddress： 0x4011</li><li>手动按下按键，从App中再跳到bootloader中，此时由于cyBtldrRunTypeB = 0x40，又留在了bootloader中。</li></ol><p>欢迎留言交流，上位机软件咱。</p>]]></content>
      
      
      <categories>
          
          <category> Infineon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
            <tag> PSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一起来DIY JLink XMC</title>
      <link href="/2022/10/21/PSoC4/JLinkXMC/"/>
      <url>/2022/10/21/PSoC4/JLinkXMC/</url>
      
        <content type="html"><![CDATA[<h3 id="JLink-XMC-4200"><a href="#JLink-XMC-4200" class="headerlink" title="JLink XMC 4200"></a>JLink XMC 4200</h3><p>偶得一块XMC4700 Kit板，板载JLink OB XMC，顺手将固件读出来先！由于今天的主角不是这板子，就不爆照了，先上一个JLink Commander：（干净的啥license都没）</p><p><img src="../../../../../medias/boardPic/2022/Infineon/Cmder.png" alt="JLink XMC Commader"></p><p>下面是主角登场：</p><p><img src="../../../../../medias/boardPic/2022/Infineon/JLinkXMCISO.png" alt="JLink XMC ISO"></p><p>带1KV隔离的官方原板，在其文档中惊喜的发现了原理图全开放！开心加意外啊，太良心了，于是就赶紧照猫画虎，赶出来了一翻版：（我的红也是很漂亮的红，不比它的差，照片拍的不好而已）</p><p><img src="../../../../../medias/boardPic/2022/Infineon/DIYMXC.png" alt="DIY JLink MXC"></p><p>参考文档：</p><p>Infineon-XMC_Link_Board_Users_Manual.pdf-UM-v01_00-EN.pdf</p><p>板子做回来后才发现：隔离芯片<strong>SI8652BB-B-IS1</strong> 贵死了…  价格已经炒上天了，这波缺货炒货的行情啥时候才能回归正常啊！哎算了，囊中羞涩，直连起来先测试验证功能吧！就跟手术缝针似的对应的PIN一一连起来就完事了，然后先连个407试试看：结果~</p><p>结果会弹框：巴拉巴拉意思是只可以连接Infineon的芯片什么的，嗯不能忍，老方法，直接对固件开刀（有固件，就可以任性为所欲为），轻松干掉这个限制，然后再加上全功能的License，Perfect~。</p><p>再下个407的程序，一路顺畅的连接下载，debug也正常，再也不会弹什么框框了。只是看JTAG时钟貌似最高只有3000 KHz，应该是固件限制了，所谓了，隔离版应该也快不到哪去。搞定收工，坐等芯片降价后把缺的都加上~</p><p><img src="../../../../../medias/boardPic/2022/Infineon/Download.png" alt="JLink MXC Download 407"></p><p>欢迎交流，莫要固件~</p>]]></content>
      
      
      <categories>
          
          <category> Infineon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
            <tag> JLink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PSoC Hex Dump</title>
      <link href="/2022/10/21/PSoC4/PSoCHexDump/"/>
      <url>/2022/10/21/PSoC4/PSoCHexDump/</url>
      
        <content type="html"><![CDATA[<h3 id="PSoC4-Programming-amp-Hex-file-Dump"><a href="#PSoC4-Programming-amp-Hex-file-Dump" class="headerlink" title="PSoC4 Programming &amp; Hex file Dump"></a>PSoC4 Programming &amp; Hex file Dump</h3><p>参考文档：Infineon-CY8C4xxx_CYBLxxxx_Programming_Specifications-Programming Specifications</p><p>文档对于PSoC4通过SWD下载进行详尽的描述，此处仅整理相关笔记及分享从Hex中dump CRC值。</p><ol><li>表一中记录Programming Values：（ID等）Acquire Chip时需要</li></ol><p><img src="../../../../../medias/boardPic/2022/Infineon/PSoCChip.png" alt="PSoC4 Chip"></p><ol start="2"><li>Hex File记录：</li></ol><p><img src="../../../../../medias/boardPic/2022/Infineon/HexFile.png" alt="Hex File"></p><ul><li><p>0x0000_0000 ：开始为User Flash，程序地址</p></li><li><p>0x9030_0000 ：CheckSum, CRC校验，2Byte，是整个user flash 的校验。</p></li><li><p>0x9040_0000 ：Flash Protection（of users rows），Protection Size = FlashSize/Row Size/8，如Flash 128KB，Flash Protection为128Byte</p></li><li><p><strong>0x9050_0000 ：MetaData - 12bytes</strong>，内容如下：</p></li></ul><table><thead><tr><th>Offset</th><th>Data Type</th><th>Length in bytes</th></tr></thead><tbody><tr><td>0x00</td><td>Hex file version - “2”</td><td>2 (big-endian)</td></tr><tr><td>0x02</td><td>Silicon ID</td><td>4 (big-endian)</td></tr><tr><td>0x06</td><td>Reserved</td><td>1</td></tr><tr><td>0x07</td><td>Reserved</td><td>1</td></tr><tr><td>0x08</td><td>Internal use</td><td>4</td></tr></tbody></table><p>Silicon ID: 程序下载时，Acquired device与此ID相比较，必须相等才可以下载，Revision ID跳过。</p><p>byte[0] : Silicon ID Hi</p><p>byte[1] : Silicon ID Lo</p><p>byte[2] : Revision ID</p><p>byte[3] : Family ID</p><ul><li>0x9060_0000 ：Chip Level protection - 1bytes</li></ul><p><img src="../../../../../medias/boardPic/2022/Infineon/chipLevelProtection.png" alt="chipLevelProtection"></p><ol start="3"><li><strong>SWD下载流程</strong>：</li></ol><p><img src="../../../../../medias/boardPic/2022/Infineon/program.png" alt="SWD program"></p><p>第一步：Acquire Chip，如果对于未接XRES的MCU，并且SWD复用为IIC的4014等芯片来说，如果使用官方下载器可能没问题，如果要自制时就需要注意，尤其是power cycle的时序：</p><p><img src="../../../../../medias/boardPic/2022/Infineon/testMode.png" alt="time of testMode"></p><p>Power UP 后，需要在5ms~5.4mS之间访问！最小的SWD时钟频率为1.5MHz，满足400uS。</p><ol start="4"><li><strong>Hex File:</strong></li></ol><table><thead><tr><th align="center">Start Code</th><th align="center">Byte Count</th><th align="center">Address</th><th align="center">Record Type</th><th align="center">Data</th><th align="center">Check Sum</th></tr></thead><tbody><tr><td align="center"><strong>:</strong></td><td align="center">1 byte</td><td align="center">2 bytes</td><td align="center">1 byte</td><td align="center">N bytes</td><td align="center">1 byte</td></tr></tbody></table><ul><li>Start code , one character — an  ASCII colon ‘:’</li><li>Byte count ,  two hex digits (1 byte) — specifies the  number of bytes in the data field. </li><li>Address, four hex digits (2 bytes) — a 16-bit address of the beginning of the memory position for the data.</li><li>Record type, two hex digits (00 to 05) — defines the type of the data field. The record types used in the hex file are as follows.<br>• 00 – Data record, which contains data and 16-bit address.<br>• 01 – End of file record, which is a file termination record and has no data. This must be the last line of the file; only one is allowed for every file.<br>• 04 – Extended linear address record,  which allows full 32-bit addressing.  Address field is 0000. Byte count is 02 . The two data bytes represent the upper 16 bits of the 32-bit address, when combined with the lower 16-bit address of the 00 type record.  </li><li>Data, a sequence of ‘n’ bytes of the data, represented by 2n hex digits.</li><li>Checksum, two hex digits (1 byte), which is  the least significant byte of the  two’s complement of  the sum of the values of all fields except fields 1 and 6 (start code ‘:’ byte and two hex digits of the checksum).</li></ul><p>如：PSoC Hex文件：</p><p><img src="../../../../../medias/boardPic/2022/Infineon/Hex.png" alt="Hex"></p><p>0x90300000地址的CRC：0xD097，可以使用notepad打开hex文件，拖到结尾直接查看crc校验。解析之：</p><p><img src="../../../../../medias/boardPic/2022/Infineon/ihexParser.png" alt="ihexParser"></p>]]></content>
      
      
      <categories>
          
          <category> Infineon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
            <tag> PSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clone MiniProg4</title>
      <link href="/2022/09/21/PSoC4/CloneMiniProg4/"/>
      <url>/2022/09/21/PSoC4/CloneMiniProg4/</url>
      
        <content type="html"><![CDATA[<h3 id="MiniProg4"><a href="#MiniProg4" class="headerlink" title="MiniProg4"></a>MiniProg4</h3><p>PSoC Creator不支持JLink，真是可惜！官方的MiniProg4相当mini精巧，可惜价格高昂，接口又很不友好，Infineon的Github上有KitProg3的开源代码，除了实现了DAPLink的功能，还有USB转IIC、SPI等外扩功能，于是就借助于它开始拼凑我的MiniProg4！</p><p>参考文档：</p><p>KitProg3：github.com/infineon/kitprog3</p><p>Infineon-<strong>AN84858</strong>_PSoC4_Programming xxx</p><p>Infineon-KitProg_Host_Protocol_Interface-UserManual</p><p>MCU就选择之前申请的CH32V307/CH32F207剩余的样片吧，高速USB，性能不弱接口丰富，加上个TFT和SD、SPI Flash还可以实现离线烧录功能，PCB在上次307的基础上简单修改了下就完成了。</p><p><img src="../../../../../medias/boardPic/2022/Infineon/miniprog4.png" alt="miniprog4"></p><p>首先实现设备的枚举：在CH32F207 HS USB CDC的例程上，按照MiniProg4的设备描述符上传所需的字符串即可。一番修改终于实现了：</p><p><img src="../../../../../medias/boardPic/2022/Infineon/Prog4Device.png" alt="MiniProg4 Device"></p><p>HID接口的DAP我不需要，直接删掉，只保留了WINUSB的DAP、Bridge和虚拟串口，设备枚举成功后，算是迈出了第一步，接下来就开始APP的移植操作。</p><p>又一番操作后，终于可以在PSoC Programmer中下载程序了，通过IO控制对外电源的输出，实现了Power Cycle，对于未接XRES并且将SWD接口配置为GPIO的4014，使用Power Cycle模式也可以下载了，好开心~</p><p>剩下的就是USB 2 IIC、SPI的移植了，日后再搞。</p><p>补一个离线下载：（目前在线和离线都已支持）</p><p>参考AN84858，将HSSP代码添加进工程中，稍作修改即可。</p><p><img src="../../../../../medias/boardPic/2022/Infineon/offDL.png" alt="增加TFT显示及SD卡"></p><p><img src="../../../../../medias/boardPic/2022/Infineon/offDlOK.png" alt="按键下载"></p><p>目前CH32的SDIO还有bug，每次上电首次初始化sdio会卡死，复位一下即可重新运行。</p><p>TODO List：</p><ol><li>USB Bridge to IIC。</li><li>USB MSC 及bootloader。</li></ol><p>附  -  官方MiniProg4的设备描述符：（欢迎一起交流）</p><pre class=" language-C"><code class="language-C">Device Descriptor:bcdUSB:             0x0200bDeviceClass:         0xEFbDeviceSubClass:      0x02bDeviceProtocol:      0x01bMaxPacketSize0:      0x08 (8)idVendor:           0x04B4 (Cypress Semiconductor)idProduct:          0xF151bcdDevice:          0x0101iManufacturer:        0x010x0409: "Cypress Semiconductor"iProduct:             0x090x0409: "Cypress MiniProg4 (CMSIS-DAP)"0x0409: "Cypress MiniProg4 (CMSIS-DAP)"0x0409: "Cypress MiniProg4 (CMSIS-DAP)"iSerialNumber:        0x800x0409: "0E23018800121400"bNumConfigurations:   0x01ConnectionStatus: DeviceConnectedCurrent Config Value: 0x01Device Bus Speed:     FullDevice Address:       0x14Open Pipes:              7Endpoint Descriptor:bEndpointAddress:     0x01  OUTTransfer Type:        BulkwMaxPacketSize:     0x0040 (64)bInterval:            0x00Endpoint Descriptor:bEndpointAddress:     0x82  INTransfer Type:        BulkwMaxPacketSize:     0x0040 (64)bInterval:            0x00Endpoint Descriptor:bEndpointAddress:     0x86  INTransfer Type:        BulkwMaxPacketSize:     0x0040 (64)bInterval:            0x00Endpoint Descriptor:bEndpointAddress:     0x07  OUTTransfer Type:        BulkwMaxPacketSize:     0x0040 (64)bInterval:            0x00Endpoint Descriptor:bEndpointAddress:     0x83  INTransfer Type:   InterruptwMaxPacketSize:     0x0008 (8)bInterval:            0x02Endpoint Descriptor:bEndpointAddress:     0x84  INTransfer Type:        BulkwMaxPacketSize:     0x0040 (64)bInterval:            0x00Endpoint Descriptor:bEndpointAddress:     0x05  OUTTransfer Type:        BulkwMaxPacketSize:     0x0040 (64)bInterval:            0x00Configuration Descriptor:wTotalLength:       0x0079bNumInterfaces:       0x04bConfigurationValue:  0x01iConfiguration:       0x090x0409: "Cypress MiniProg4 (CMSIS-DAP)"0x0409: "Cypress MiniProg4 (CMSIS-DAP)"0x0409: "Cypress MiniProg4 (CMSIS-DAP)"bmAttributes:         0x80 (Bus Powered )MaxPower:             0xC8 (400 Ma)Interface Descriptor:bInterfaceNumber:     0x00bAlternateSetting:    0x00bNumEndpoints:        0x02bInterfaceClass:      0xFFbInterfaceSubClass:   0x00bInterfaceProtocol:   0x00iInterface:           0x090x0409: "Cypress MiniProg4 (CMSIS-DAP)"0x0409: "Cypress MiniProg4 (CMSIS-DAP)"0x0409: "Cypress MiniProg4 (CMSIS-DAP)"Endpoint Descriptor:bEndpointAddress:     0x01  OUTTransfer Type:        BulkwMaxPacketSize:     0x0040 (64)bInterval:            0x00Endpoint Descriptor:bEndpointAddress:     0x82  INTransfer Type:        BulkwMaxPacketSize:     0x0040 (64)bInterval:            0x00Interface Descriptor:bInterfaceNumber:     0x01bAlternateSetting:    0x00bNumEndpoints:        0x02bInterfaceClass:      0xFFbInterfaceSubClass:   0x00bInterfaceProtocol:   0x00iInterface:           0x110x0409: "MiniProg4 bridge"Endpoint Descriptor:bEndpointAddress:     0x86  INTransfer Type:        BulkwMaxPacketSize:     0x0040 (64)bInterval:            0x00Endpoint Descriptor:bEndpointAddress:     0x07  OUTTransfer Type:        BulkwMaxPacketSize:     0x0040 (64)bInterval:            0x00Unknown Descriptor:bDescriptorType:      0x0BbLength:              0x0808 0B 02 02 02 02 00 00 Interface Descriptor:bInterfaceNumber:     0x02bAlternateSetting:    0x00bNumEndpoints:        0x01bInterfaceClass:      0x02bInterfaceSubClass:   0x02bInterfaceProtocol:   0x01iInterface:           0x0F0x0409: "KitProg3 USBUART"Unknown Descriptor:bDescriptorType:      0x24bLength:              0x0505 24 00 10 01 Unknown Descriptor:bDescriptorType:      0x24bLength:              0x0404 24 02 02 Unknown Descriptor:bDescriptorType:      0x24bLength:              0x0505 24 06 02 03 Unknown Descriptor:bDescriptorType:      0x24bLength:              0x0505 24 01 00 03 Endpoint Descriptor:bEndpointAddress:     0x83  INTransfer Type:   InterruptwMaxPacketSize:     0x0008 (8)bInterval:            0x02Interface Descriptor:bInterfaceNumber:     0x03bAlternateSetting:    0x00bNumEndpoints:        0x02bInterfaceClass:      0x0AbInterfaceSubClass:   0x00bInterfaceProtocol:   0x00iInterface:           0x040x0409: "KitProg3 USBUART"Endpoint Descriptor:bEndpointAddress:     0x84  INTransfer Type:        BulkwMaxPacketSize:     0x0040 (64)bInterval:            0x00Endpoint Descriptor:bEndpointAddress:     0x05  OUTTransfer Type:        BulkwMaxPacketSize:     0x0040 (64)bInterval:            0x00</code></pre>]]></content>
      
      
      <categories>
          
          <category> Infineon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
            <tag> PSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PSoC4 SoftUart &amp; CmbackTrace -- Hardfault</title>
      <link href="/2022/08/21/PSoC4/PSoC4SoftUart/"/>
      <url>/2022/08/21/PSoC4/PSoC4SoftUart/</url>
      
        <content type="html"><![CDATA[<h3 id="PSoC4-SoftUart-amp-CmbackTrace-–-Hardfault"><a href="#PSoC4-SoftUart-amp-CmbackTrace-–-Hardfault" class="headerlink" title="PSoC4 SoftUart &amp; CmbackTrace – Hardfault"></a>PSoC4 SoftUart &amp; CmbackTrace – Hardfault</h3><p>使用CmBackTrace定位PSoC4的hardfault！</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>调试PSoC4 时很不巧遇到了Hardfault，debug发现程序运行了一段时间后跳到了Cm0plusStart.c中的CY_ISR ( IntDefaultHandler ) 中，查看vector发现，NMI中断和hardfault的处理函数都是调用该函数，于是想到使用CmbackTrace来定位是哪条语句引起的！</p><h3 id="CmBackTrace简介"><a href="#CmBackTrace简介" class="headerlink" title="CmBackTrace简介"></a>CmBackTrace简介</h3><p><a href="https://github.com/armink/CmBacktrace" target="_blank" rel="noopener">CmBacktrace</a> （Cortex Microcontroller Backtrace）是一款针对 <a href="https://so.csdn.net/so/search?q=ARM&spm=1001.2101.3001.7020" target="_blank" rel="noopener">ARM</a> Cortex-M 系列 MCU 的错误代码自动追踪、定位，错误原因自动分析的开源库。主要特性如下：</p><ul><li>支持的错误包括：<ul><li>断言（<a href="https://so.csdn.net/so/search?q=assert&spm=1001.2101.3001.7020" target="_blank" rel="noopener">assert</a>）</li><li>故障（Hard Fault, Memory Management Fault, Bus Fault, Usage Fault, Debug Fault）</li></ul></li><li>故障原因 <strong>自动诊断</strong> ：可在故障发生时，自动分析出故障的原因，定位发生故障的代码位置，而无需再手动分析繁杂的故障寄存器；</li><li>输出错误现场的 <strong>函数调用栈</strong>（需配合 addr2line 工具进行精确定位），还原发生错误时的现场信息，定位问题代码位置、逻辑更加快捷、精准。也可以在正常状态下使用该库，获取当前的函数调用栈；</li><li>支持 裸机 及以下操作系统平台：<ul><li><a href="http://www.rt-thread.org/" target="_blank" rel="noopener">RT-Thread</a></li><li>UCOS</li><li>FreeRTOS</li></ul></li><li>根据错误现场状态，输出对应的 线程栈 或 C 主栈；</li><li>故障诊断信息支持多国语言（目前：简体中文、英文）；</li><li>适配 Cortex-M0/M3/M4/M7 MCU；</li><li>支持 IAR、KEIL、GCC 编译器；</li></ul><p>Note: 作者朱天龙 (Armink)，开源了FlashDB、EasyLogger、CmBacktrace、EasyFlash、SFUD等等非常好用的嵌入式组件，感恩~  作者Github：<a href="https://github.com/armink" target="_blank" rel="noopener">https://github.com/armink</a> ，前往作者的Github下载下最新版本的CmBackTrace，开始移植。</p><h3 id="PSoC-Soft-UART-–-printf"><a href="#PSoC-Soft-UART-–-printf" class="headerlink" title="PSoC Soft UART – printf"></a>PSoC Soft UART – printf</h3><p>PSoC Creator中神奇的uart组件 – Software Transmit UART，只用一个IO，汇编指令实现的软uart tx。选择它并配置波特率9600，UARTDbg_Start() 后即可使用。<br><img src="../../../../../medias/boardPic/2022/Infineon/SoftUart.png" alt="SoftUart"></p><p>printf输出重定向至软串口发送：</p><pre class=" language-C"><code class="language-C">//Heap Size需要改大 -- 0x0400？int _write(int file, char *ptr, int len){    int i;    file = file;    for (i = 0; i < len; i++)    {        UARTDbg_PutChar(*ptr++);    }    return len;}</code></pre><p>Note： Heap Size一定要改大！！！<br>程序中包含下头文件 “stdio.h”，然后就可以愉快的调用printf啦。</p><h3 id="CmBackTrace移植"><a href="#CmBackTrace移植" class="headerlink" title="CmBackTrace移植"></a>CmBackTrace移植</h3><ol><li>将cm_backtrace相关的文件添加到工程中，配置cmb_cfg.h:</li></ol><pre class=" language-C"><code class="language-C">#ifndef _CMB_CFG_H_#define _CMB_CFG_H_/* print line, must config by user */#define cmb_println(...)               printf(__VA_ARGS__);printf("\r\n")/* enable bare metal(no OS) platform */#define CMB_USING_BARE_METAL_PLATFORM/* cpu platform type, must config by user */#define CMB_CPU_PLATFORM_TYPE          CMB_CPU_ARM_CORTEX_M0/* enable dump stack information */#define CMB_USING_DUMP_STACK_INFO/* language of print information */#define CMB_PRINT_LANGUAGE             CMB_PRINT_LANUUAGE_ENGLISH#endif /* _CMB_CFG_H_ */</code></pre><ol start="2"><li>修改Cm0plusStart.c中的  //&amp;IntDefaultHandler,      /* The hard fault handler     3 */<br>注释掉并修改为&amp;HardFault_Handler, 使用CmBackTrace的HardFault_Handler处理。</li><li>修改cmb_def.h中CMB_CSTACK_BLOCK_START和CMB_CSTACK_BLOCK_END的定义，<br>Creator使用的是GNUC的GCC，所以修改#elif defined(<strong>GNUC</strong>)中：<pre class=" language-C"><code class="language-C">#define CMB_CSTACK_BLOCK_START         __cy_heap_end#define CMB_CSTACK_BLOCK_END           __cy_stack</code></pre></li><li>移植demo中的hardfault测试函数：除0和unlign，结果发现都无法引起hardfault，增加一个abnormal_access的测试函数：</li></ol><pre class=" language-C"><code class="language-C">void fault_test_by_unalign(void) {    volatile int * SCB_CCR = (volatile int *) 0xE000ED14; // SCB->CCR    volatile int * p;    volatile int value;    *SCB_CCR |= (1 << 3); /* bit3: UNALIGN_TRP. */    p = (int *) 0x00;    value = *p;    printf("addr:0x%02X value:0x%08X\r\n", (int) p, value);    p = (int *) 0x04;    value = *p;    printf("addr:0x%02X value:0x%08X\r\n", (int) p, value);    p = (int *) 0x03;    value = *p;    printf("addr:0x%02X value:0x%08X\r\n", (int) p, value);}void fault_test_by_div0(void) {    volatile int * SCB_CCR = (volatile int *) 0xE000ED14; // SCB->CCR    int x, y, z;    *SCB_CCR |= (1 << 4); /* bit4: DIV_0_TRP. */    x = 10;    y = 0;    z = x / y;    printf("div0: %d\r\n", z);}void fault_test_abnormal_access(){    uint32_t addr = 0xCCCCCCCC;    uint32_t val = *(volatile uint32_t*)addr;    printf("abnormal_access: %d! \r\n",val);}</code></pre><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>main中调用，编译、下载运行：</p><pre class=" language-C"><code class="language-C">cm_backtrace_init("SoftUart", HARDWARE_VERSION, SOFTWARE_VERSION);uartDbgInit();fault_test_by_div0();fault_test_by_unalign();fault_test_abnormal_access(); </code></pre><p>打开串口调试助手：（除0和非对齐访问，都可以正常运行..）<br><img src="../../../../../medias/boardPic/2022/Infineon/hardfault.png" alt="Hardfault"></p><p>将add2link拷编译目录下并打开命令行程序，运行其中提示的<br>addr2line -e SoftUart.elf -a -f 000006b4 000006e6 000007a8 0000001a</p><p><img src="../../../../../medias/boardPic/2022/Infineon/add2line.png" alt="add2line"><br>找到对应的 main.c : 64行：<br><img src="../../../../../medias/boardPic/2022/Infineon/abnormal_access.png" alt="abnormal_access"></p><p>就是它引起的Hardfault ！有了它，再也不怕hardfault了~</p><p>by the way：<br>修改Cm0plusStart.c，重新编译生成时有时修改了的HardFault会被默认替换掉，使用时注意下即可。欢迎交流~</p>]]></content>
      
      
      <categories>
          
          <category> Infineon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
            <tag> PSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT常用命令</title>
      <link href="/2022/08/02/GITcmds/"/>
      <url>/2022/08/02/GITcmds/</url>
      
        <content type="html"><![CDATA[<h2 id="GIT常用命令"><a href="#GIT常用命令" class="headerlink" title="GIT常用命令"></a>GIT常用命令</h2><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><ul><li><p>在当前目录新建一个Git代码库<br>$ git init</p></li><li><p>新建一个目录，将其初始化为Git代码库<br>$ git init [project-name]</p></li><li><p>下载一个项目和它的整个代码历史<br>$ git clone [url]</p></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><p>显示当前的Git配置<br>$ git config –list</p></li><li><p>编辑Git配置文件<br>$ git config -e [–global]</p></li><li><p>设置提交代码时的用户信息<br>$ git config [–global] user.name “[name]”<br>$ git config [–global] user.email “[email address]”</p></li></ul><h3 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h3><ul><li><p>添加指定文件到暂存区<br>$ git add [file1] [file2] …</p></li><li><p>添加指定目录到暂存区，包括子目录<br>$ git add [dir]</p></li><li><p>添加当前目录的所有文件到暂存区<br>$ git add .</p></li><li><p>添加每个变化前，都会要求确认</p></li><li><p>对于同一个文件的多处变化，可以实现分次提交<br>$ git add -p</p></li><li><p>删除工作区文件，并且将这次删除放入暂存区<br>$ git rm [file1] [file2] …</p></li><li><p>停止追踪指定文件，但该文件会保留在工作区<br>$ git rm –cached [file]</p></li><li><p>改名文件，并且将这个改名放入暂存区<br>$ git mv [file-original] [file-renamed]</p></li></ul><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><ul><li><p>提交暂存区到仓库区<br>$ git commit -m [message]</p></li><li><p>提交暂存区的指定文件到仓库区<br>$ git commit [file1] [file2] … -m [message]</p></li><li><p>提交工作区自上次commit之后的变化，直接到仓库区<br>$ git commit -a</p></li><li><p>提交时显示所有diff信息<br>$ git commit -v</p></li><li><p>使用一次新的commit，替代上一次提交</p></li><li><p>如果代码没有任何新变化，则用来改写上一次commit的提交信息<br>$ git commit –amend -m [message]</p></li><li><p>重做上一次commit，并包括指定文件的新变化<br>$ git commit –amend [file1] [file2] …</p></li></ul><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul><li><p>列出所有本地分支<br>$ git branch</p></li><li><p>列出所有远程分支<br>$ git branch -r</p></li><li><p>列出所有本地分支和远程分支<br>$ git branch -a</p></li><li><p>新建一个分支，但依然停留在当前分支<br>$ git branch [branch-name]</p></li><li><p>新建一个分支，并切换到该分支<br>$ git checkout -b [branch]</p></li><li><p>新建一个分支，指向指定commit<br>$ git branch [branch] [commit]</p></li><li><p>新建一个分支，与指定的远程分支建立追踪关系<br>$ git branch –track [branch] [remote-branch]</p></li><li><p>切换到指定分支，并更新工作区<br>$ git checkout [branch-name]</p></li><li><p>切换到上一个分支<br>$ git checkout -</p></li><li><p>建立追踪关系，在现有分支与指定的远程分支之间<br>$ git branch –set-upstream [branch] [remote-branch]</p></li><li><p>合并指定分支到当前分支<br>$ git merge [branch]</p></li><li><p>选择一个commit，合并进当前分支<br>$ git cherry-pick [commit]</p></li><li><p>删除分支<br>$ git branch -d [branch-name]</p></li><li><p>删除远程分支<br>$ git push origin –delete [branch-name]<br>$ git branch -dr [remote/branch]</p></li></ul><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><ul><li><p>列出所有tag<br>$ git tag</p></li><li><p>新建一个tag在当前commit<br>$ git tag [tag]</p></li><li><p>新建一个tag在指定commit<br>$ git tag [tag] [commit]</p></li><li><p>删除本地tag<br>$ git tag -d [tag]</p></li><li><p>删除远程tag<br>$ git push origin :refs/tags/[tagName]</p></li><li><p>查看tag信息<br>$ git show [tag]</p></li><li><p>提交指定tag<br>$ git push [remote] [tag]</p></li><li><p>提交所有tag<br>$ git push [remote] –tags</p></li><li><p>新建一个分支，指向某个tag<br>$ git checkout -b [branch] [tag]</p></li></ul><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><ul><li><p>显示有变更的文件<br>$ git status</p></li><li><p>显示当前分支的版本历史<br>$ git log</p></li><li><p>显示commit历史，以及每次commit发生变更的文件<br>$ git log –stat</p></li><li><p>搜索提交历史，根据关键词<br>$ git log -S [keyword]</p></li><li><p>显示某个commit之后的所有变动，每个commit占据一行<br>$ git log [tag] HEAD –pretty=format:%s</p></li><li><p>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件<br>$ git log [tag] HEAD –grep feature</p></li><li><p>显示某个文件的版本历史，包括文件改名<br>$ git log –follow [file]<br>$ git whatchanged [file]</p></li><li><p>显示指定文件相关的每一次diff<br>$ git log -p [file]</p></li><li><p>显示过去5次提交<br>$ git log -5 –pretty –oneline</p></li><li><p>显示所有提交过的用户，按提交次数排序<br>$ git shortlog -sn</p></li><li><p>显示指定文件是什么人在什么时间修改过<br>$ git blame [file]</p></li><li><p>显示暂存区和工作区的差异<br>$ git diff</p></li><li><p>显示暂存区和上一个commit的差异<br>$ git diff –cached [file]</p></li><li><p>显示工作区与当前分支最新commit之间的差异<br>$ git diff HEAD</p></li><li><p>显示两次提交之间的差异<br>$ git diff [first-branch]…[second-branch]</p></li><li><p>显示今天你写了多少行代码<br>$ git diff –shortstat “@{0 day ago}”</p></li><li><p>显示某次提交的元数据和内容变化<br>$ git show [commit]</p></li><li><p>显示某次提交发生变化的文件<br>$ git show –name-only [commit]</p></li><li><p>显示某次提交时，某个文件的内容<br>$ git show [commit]:[filename]</p></li><li><p>显示当前分支的最近几次提交<br>$ git reflog</p></li></ul><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><ul><li><p>下载远程仓库的所有变动<br>$ git fetch [remote]</p></li><li><p>显示所有远程仓库<br>$ git remote -v</p></li><li><p>显示某个远程仓库的信息<br>$ git remote show [remote]</p></li><li><p>增加一个新的远程仓库，并命名<br>$ git remote add [shortname] [url]</p></li><li><p>取回远程仓库的变化，并与本地分支合并<br>$ git pull [remote] [branch]</p></li><li><p>上传本地指定分支到远程仓库<br>$ git push [remote] [branch]</p></li><li><p>强行推送当前分支到远程仓库，即使有冲突<br>$ git push [remote] –force</p></li><li><p>推送所有分支到远程仓库<br>$ git push [remote] –all</p></li></ul><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><ul><li><p>恢复暂存区的指定文件到工作区<br>$ git checkout [file]</p></li><li><p>恢复某个commit的指定文件到暂存区和工作区<br>$ git checkout [commit] [file]</p></li><li><p>恢复暂存区的所有文件到工作区<br>$ git checkout .</p></li><li><p>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变<br>$ git reset [file]</p></li><li><p>重置暂存区与工作区，与上一次commit保持一致<br>$ git reset –hard</p></li><li><p>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br>$ git reset [commit]</p></li><li><p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致<br>$ git reset –hard [commit]</p></li><li><p>重置当前HEAD为指定commit，但保持暂存区和工作区不变<br>$ git reset –keep [commit]</p></li><li><p>新建一个commit，用来撤销指定commit</p></li><li><p>后者的所有变化都将被前者抵消，并且应用到当前分支<br>$ git revert [commit]</p></li><li><p>暂时将未提交的变化移除，稍后再移入<br>$ git stash<br>$ git stash pop</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>生成一个可供发布的压缩包<br>$ git archive</li></ul>]]></content>
      
      
      <categories>
          
          <category> GIT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PSoC4 UART</title>
      <link href="/2022/07/22/PSoC4/PSoC4CH4Uart/"/>
      <url>/2022/07/22/PSoC4/PSoC4CH4Uart/</url>
      
        <content type="html"><![CDATA[<h3 id="PSoC4-SCB-之-UART"><a href="#PSoC4-SCB-之-UART" class="headerlink" title="PSoC4 SCB 之 UART"></a>PSoC4 SCB 之 UART</h3><p>参考文档：</p><ol><li>Infineon-Component_PSoC_4_SCB_V2.0-Software Module Datasheets-v04_00-EN</li><li>Infineon-PSoC_4100S_Family_PSoC_4_Registers_Technical_Reference_Manual_(TRM)-AdditionalTechnicalInformation-v04_00-EN</li></ol><h3 id="SCB-gt-UART"><a href="#SCB-gt-UART" class="headerlink" title="SCB -&gt; UART"></a>SCB -&gt; UART</h3><p>PSoC4100S Plus拥有五个运行时可重新配置的独立串行通信模块（<strong>SCB</strong>），可配置为I2C、SPI或UART功能。</p><p>UART模式：运行速度高达1Mbps的全功能UART，支持汽车单线接口LIN、红外接口（IrDA）和智能卡（ISO7816）协议。此外还支持9位多处理器模式，此模式允许寻址连接到通用RX和TX线的外设。支持通用UART功能，如奇偶校验、中断检测以及帧错误。一个8字节深度的FIFO。</p><p>在PSoC Creator中创建新工程，TopDesign中添加UART，并重命名为UARTBtl （为UART Bootloader用），然后配置其参数如下：</p><p><img src="../../../../../medias/boardPic/2022/Infineon/UartCfg.png" alt="MCB UART配置"></p><p>主要是串口收发中断的配置：使能Tx FIFO empty 和 RX FIFO not empty 中断，FIFO buffer设置为8，这样发送时一次可以填入8个字节以减小进中断的频次。<br>接收中断很遗憾不支持空闲中断，只能配合定时器中断实现超时成帧判断。<br>（如果支持空闲中断可以配合RX FIFO Level使用以降低进接收中断的频次，比如设置为4字节，如果接收缓冲区中有3个字节的话，就没法产生中断了..）</p><p>完成配置后开始撸代码，老规矩，套我之前的串口收发处理 – 既然支持五个SCB自然不能写五套串口收发处理代码，那太啰嗦了。</p><p>先定义UART的数据结构：</p><pre class=" language-C"><code class="language-C">typedef void (func)(uint8_t);typedef uint8_t (funcRt)(void);typedef struct{    uint8_t * rbuf;        //接收缓冲区    uint16_t rwr;            uint16_t rlen;    uint8_t rframe;        //接收成帧标志    uint8_t rtmr;       //接收超时timer    const uint8_t * sbuf;    //发送缓冲区    uint16_t slen;            //发送长度    uint16_t swr;    func * setSendIrqEn;    //发送FIFO空中断使能设置    func * sendDat;            //发送一个字节    funcRt * sFifoNotFull;    //发送Fifo没空判断，1：Not Full}strUart;</code></pre><p>串口中断服务处理函数：</p><pre class=" language-C++"><code class="language-C++">CY_ISR(UARTBtl_RXTXINT)     //uart irq proc{//----------TX IRQ, Fifo empty      uint32 inter_resource = UARTBtl_GetTxInterruptSourceMasked();    uint8_t rdat = 0;    if (inter_resource & UARTBtl_INTR_TX_EMPTY)    {        UARTBtl_ClearTxInterruptSource(UARTBtl_INTR_TX_EMPTY);        bsp_uart_send_irq(&uartBtl);    }//----------RX IRQ, Fifo not empty, recv bytes    inter_resource = UARTBtl_GetRxInterruptSourceMasked();    if (inter_resource &  UARTBtl_INTR_RX_NOT_EMPTY)    {        do        {            rdat = UARTBtl_SpiUartReadRxData();            bsp_uart_recv_dat(&uartBtl,rdat);        } while (UARTBtl_SpiUartGetRxBufferSize() != 0);        UARTBtl_ClearRxInterruptSource(UARTBtl_INTR_RX_NOT_EMPTY);    }}</code></pre><p>串口发送相关函数配置：</p><pre class=" language-C++"><code class="language-C++">//uart send fifo empty irqvoid bsp_uart_send_irq(strUart * uart)     {    if(uart->swr >= uart->slen)    //uart send done!    {        uart->swr = 0;        uart->slen = 0;          uart->setSendIrqEn(0);    //disable send IRQ after send done!        return;    }           //如果fifo没满并且发送缓冲区中有数据就一直往里填    while(uart->sFifoNotFull())    {        if(uart->swr < uart->slen)        {            uart->sendDat(uart->sbuf[uart->swr]);            uart->swr++;               }        else        {            break;        }    }}// 发送函数，当数据填入缓冲区后调用，使能FIFO空中断，进入中断后会调用上面函数处理uint8_t bsp_uart_send(strUart * uart,uint16_t len){    uart->slen = len;    uart->swr = 0;    uart->setSendIrqEn(1);}//获取发送缓冲区指针，向发送缓冲区中填数时需要等待发送完成uint8_t * bsp_uart_get_sbuf(strUart * uart){    while(uart->slen != 0);     //等待上次发送完成    return (uart->sbuf);}</code></pre><p>串口接收处理：</p><pre class=" language-C++"><code class="language-C++">void bsp_uart_recv_dat(strUart * uart, uint8_t dat){    uart->rbuf[uart->rwr] = dat;    uart->rwr++;    if(uart->rwr >= U_RX_MAX)    {        uart->rwr = 0;    }    uart->rtmr = TMR_OVER;}void bsp_uart_tmr_over_check(strUart * uart){    if(uart->rtmr)    {        uart->rtmr--;        if(uart->rtmr == 0)        {            uart->rframe = 1;        }    }}</code></pre><p>接收处理大体流程如下：<strong>接收成帧的判断</strong>：<br>接收中断中将接收的数据放入接收缓冲区中，并设置接收超时时间，9600波特率接收一个字节的时间约为1ms，设置超时时间为3ms或5ms，超时后即认为接收成帧。<br>除非发送方发送时不是连续发送的（比如linux系统的设备，曾遇过发送一帧数据时，分了几段来发，后来把超时时间间隔设大才OK）</p><p>串口中间层代码：</p><pre class=" language-C++"><code class="language-C++">void uartBtlEnSendIrq(uint8_t en){    // en ? UARTBtl_ENABLE_INTR_TX(UARTBtl_INTR_TX_EMPTY) : UARTBtl_DISABLE_INTR_TX(UARTBtl_INTR_TX_EMPTY);    if(en)    {        UARTBtl_ENABLE_INTR_TX(UARTBtl_INTR_TX_EMPTY);    }    else    {        UARTBtl_DISABLE_INTR_TX(UARTBtl_INTR_TX_EMPTY);    }}void uartBtlSendDat(uint8_t dat){    UARTBtl_TX_FIFO_WR_REG = dat;}uint8_t uartBtlSendFifoNotFullChk(){    return (UARTBtl_SPI_UART_FIFO_SIZE != UARTBtl_GET_TX_FIFO_ENTRIES) ? 1 : 0;}</code></pre><p>串口初始化代码：</p><pre class=" language-C++"><code class="language-C++">void uartBtlDataInit(){    memset(&uartBtl,0,sizeof(uartBtl));        uartBtl.rbuf = uartBtlRbuf;    uartBtl.sbuf = uartBtlSbuf;        uartBtl.setSendIrqEn = uartBtlEnSendIrq;    uartBtl.sendDat = uartBtlSendDat;    uartBtl.sFifoNotFull = uartBtlSendFifoNotFullChk;}void uartBtlInit(){    uartBtlDataInit();    UARTBtl_Start();    UARTBtl_SetCustomInterruptHandler(UARTBtl_RXTXINT);     //UART_CHECKPART_RXTXINT    UARTBtl_DISABLE_INTR_TX(UARTBtl_INTR_TX_EMPTY);         //disable Tx IRQ    UARTBtl_ENABLE_INTR_RX(UARTBtl_INTR_RX_NOT_EMPTY);      //enable Rx IRQ}</code></pre><p>串口收发测试：</p><pre class=" language-C++"><code class="language-C++">void uartBtlSendTest(){    uint16_t j = 0;    uint8_t * sbuf = bsp_uart_get_sbuf(&uartBtl);        sbuf[j++] = 'H';    sbuf[j++] = 'e';    sbuf[j++] = 'l';    sbuf[j++] = 'l';    sbuf[j++] = 'o';    sbuf[j++] = '!';    sbuf[j++] = '\r';    sbuf[j++] = '\n';    bsp_uart_send(&uartBtl,j);}void uartBtlSendBuf(uint8_t * buf,uint16_t len){    uint8_t * sbuf = bsp_uart_get_sbuf(&uartBtl);    memcpy(sbuf,buf,len);    bsp_uart_send(&uartBtl,len);}void task_uartBtl_recv(){    if(uartBtl.rframe)    {        uartBtl.rframe = 0;            //简单测试：将收到的数据发送回去        uartBtlSendBuf(uartBtl.rbuf,uartBtl.rwr );               uartBtl.rwr = 0;    }}</code></pre><p>打开串口调试助手，收发测试：（与仿真器串口相连的UART PIN： P7_0 - U_RX，P7_1 - T_RX）<br><img src="../../../../../medias/boardPic/2022/Infineon/uartCom.png" alt="串口收发"></p><p>程序中放了个一个uart、一个led、一个timer，编译后占用：<br>Flash used: 3510 of 131072 bytes (2.7%).<br>SRAM used: 3104 of 16384 bytes (18.9%). Stack: 2048 bytes. Heap: 128 bytes.<br>如果使用串口Bootloader，还需要精简代码才行，不能超过4KB，继续努力~</p>]]></content>
      
      
      <categories>
          
          <category> Infineon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
            <tag> PSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PSoC4 Capsense电容触摸</title>
      <link href="/2022/07/02/PSoC4/PSoC4CH3CapSense/"/>
      <url>/2022/07/02/PSoC4/PSoC4CH3CapSense/</url>
      
        <content type="html"><![CDATA[<h3 id="PSoC-Capsense"><a href="#PSoC-Capsense" class="headerlink" title="PSoC Capsense"></a>PSoC Capsense</h3><p>参考文档：</p><ol><li>AN64846_Getting_Started_with_CapSense-ApplicationNotes-v26_00</li><li>AN85951_PSoC_4_and_PSoC_6_MCU_CapSense_Design_Guide-ApplicationNotes</li></ol><h3 id="电容感应方法"><a href="#电容感应方法" class="headerlink" title="电容感应方法"></a>电容感应方法</h3><h4 id="自电容"><a href="#自电容" class="headerlink" title="自电容"></a>自电容</h4><p>自电容使用一个引脚，并测量该引脚与地之间的电容。原理：驱动与传感器相连的引脚上的电流并测量电压。若将手指放在传感器上，则测得的电容会增加。适合用于单点触摸传感器，如按键和滑条。</p><p>在CapSense自电容系统中，<strong>由控制器测量的传感器电容称为Cs</strong>。当<strong>无触摸时，CS等于系统寄生电容Cp</strong>。Cp与传感器垫块周围的电场有关。当手指碰触传感器表面时，手指和传感器垫片会通过覆盖层形成一个简单的平行板电容，该电容称为<strong>手指电容，即Cf</strong>。Cf是分部电容的简化形式，包括人体和返回路径对电路板接地层的效应。其公式：<br>$$<br>Cf = (ε0 * εr A) / D<br>$$<br>ε0 = 空气介电常数</p><p>εr = 覆盖层的介电常数</p><p>A = 手指与传感器垫片覆盖层的接触面积</p><p>D = 覆盖层的厚度 </p><p>当手指触摸时，Cs等于Cp和Cf的总和，即 <strong>Cs = Cp + Cf</strong></p><h4 id="互电容"><a href="#互电容" class="headerlink" title="互电容"></a>互电容</h4><p>互电容感应测量两个电极间的电容，其中一个电极称为发送电极TX，另一个称为接收电极RX。如下图示：</p><p><img src="../../../../../medias/boardPic/2022/Infineon/MTouch.png" alt="互电容"></p><p><strong>互电容适用于多点触摸系统，如触摸屏和触摸板。</strong></p><h3 id="PCB-Design"><a href="#PCB-Design" class="headerlink" title="PCB Design"></a>PCB Design</h3><p>Cp的主要组成成分是走线和电容，<strong>应尽量减少走线长度和宽度，以降低Cp</strong>。降低走线长度会增加抗噪能力，此外，通过使用屏蔽信号驱动网格，也可以降低Cp值。以下情况会增加Cp：</p><ul><li>传感器垫片大小增加</li><li>走线长度和宽度增加</li><li>传感器垫片和接地网格之间的间隙减少</li></ul><p>如果由于较长的走线或接地层所引起的传感器Cp的值非常大，您可以使用互电容感应的方法，以便在Cp值较高的情况下仍不降低灵敏度。使用互电容感应方法时，CapSense传感器的灵敏度独立于传感器Cp。</p><h4 id="自电容按键设计"><a href="#自电容按键设计" class="headerlink" title="自电容按键设计"></a>自电容按键设计</h4><p>推荐为CapSense按键使用<strong>圆型传感器</strong>垫片。也可以使用圆角矩形垫片，应避免尖角（小于90°叫）垫片。</p><p>按键直径范围应介于5mm到15mm之间，其中<strong>10mm适用于大多数应用</strong>。对于较厚的覆盖层，使用较大的按键直径。</p><p><strong>传感器垫片和地网格之间的间隙宽度应等于覆盖层的厚度，其范围为0.5mm到2mm之间。</strong>例如覆盖层的厚度为1mm，推荐使用1mm宽的间隙。但对于3mm厚的覆盖层，则只应使用2mm宽的间隙。</p><p>对于双层PCB，</p><ol><li>将传感器放置在PCB的顶层上。</li><li>将组件和传感器走线布置在PCB的底层上。</li></ol><p>推荐在传感器周围以及传感器下方的PCB板底层上使用网格接地层，规则：<strong>在顶层信号线宽度为7mil，它们的间距为45mil，在底层上该间距为70mil。</strong></p><p><img src="../../../../../medias/boardPic/2022/Infineon/PCB2Layer.png" alt="PCB 2 Layer"></p><p>对于四层PCB：</p><ol><li>将传感器放置在PCB的顶层上。</li><li>在第二层上路由传感器走线。</li><li>放置一个填充网格（走线宽度为7mil，网格宽度为70mil），并使其连接到第三层的接地层。</li><li>在底层上放置组件，未使用的区域使用铜网格填充（走线宽度为7mil，网格宽度为70mil），并使其接地。</li></ol><p>还要注意：</p><ul><li>尽量缩短从CapSense控制器引脚到传感器导电片之间走线的长度，以优化信号强度。</li><li>在离控制器引脚10mm范围内安装串联电阻，以降低射频干扰并提供ESD保护（560R）</li><li>将控制器和其他组件安装在PCB的底层上。</li><li>避免在传感器和控制器引脚之间使用连接器，因为连接器会增加Cp并降低抗噪能力。</li></ul><p>接地层：</p><p>在传感器的顶层和底层都应该进行接地层填充。铺地在CapSense传感器导电片附近时，在维持高水平的CapSense信号和增加系统抗噪能力之间需要进行权衡。网格接地规则是：</p><ul><li><strong>25%在顶层 （7mil线路，45mil间距）</strong></li><li><strong>17%在底层（7mil线路，70mil间距）</strong></li></ul><p>如下图示：</p><p><img src="../../../../../medias/boardPic/2022/Infineon/CapPCBLayout.png" alt="CapSense PCB Layout"></p><h4 id="走线长度和宽度"><a href="#走线长度和宽度" class="headerlink" title="走线长度和宽度"></a>走线长度和宽度</h4><ul><li>标准PCB的最大走线长度为12英寸（即300mm），柔性电路的长度应该为2英寸。</li><li>走线宽度不能大于7mil（0.18mm），CapSense走线必须围绕着网格接地，且走线与接地的间隙介于10mil到20mil（0.25mm到0.51mm）之间。</li></ul><h3 id="Sigma-Delta转换器"><a href="#Sigma-Delta转换器" class="headerlink" title="Sigma Delta转换器"></a>Sigma Delta转换器</h3><p>Sigma  Delta转换器将输入电流转换为一个相应的数字计数值。该转换器包括一个<strong>Sigma-delta转换器、一个时钟发生器和两个源电流/灌电流数模转换器（IDAC）</strong>。</p><p>Sigma-delta调制器以打开/关闭方式来控制调制器IDAC的电流。补偿IDAC始终处于打开或关闭状态，可在单IDAC 模式或双IDAC模式下运行。 </p><ul><li>在单IDAC 模式下，调制IDAC由Sigma-delta调制器控制；补偿IDAC始终为OFF状态。</li><li>在双IDAC 模式下，调制IDAC由Sigma-delta调制器控制；补偿IDAC始终为ON状态。</li></ul><p>Sigma-delta转换器还要求一个外部集成电容（即调制电容CMOD），CMOD的建议值为2.2 nF。调制器保持CMOD上的电压等于VREF。在下列某种模式下工作：</p><ul><li><strong>IDAC源模式</strong>：在该模式中，开关电容电路将通过AMUXBUS A接收CMOD的电流，然后，IDAC为AMUXBUS A供电，以使其电压平衡。 </li><li><strong>IDAC 灌电流模式</strong> ：在该模式中，IDAC 将通过AMUXBUS A接收CMOD的电流，然后，开关电容电路为AMUXBUS A供电，以使其电压平衡。 </li></ul><p>在这两种情况下，IDAC电流根据CMOD上微弱的电压变化在ON和OFF状态间进行切换，以保持CMOD的电压为VREF。</p><p><img src="../../../../../medias/boardPic/2022/Infineon/DY1.png" alt="单IDAC源电流模式中的原始计数"></p><p><img src="../../../../../medias/boardPic/2022/Infineon/DG2.png" alt="单IDAC灌电流模式中的原始计数 "></p><p><img src="../../../../../medias/boardPic/2022/Infineon/SY3.png" alt="双IDAC源电流模式中的原始计数 "></p><p><img src="../../../../../medias/boardPic/2022/Infineon/SG4.png" alt="双IDAC灌电流模式中的原始计数"></p><p>注意：原始计数值始终为正值，这是必要条件。</p><p><img src="../../../../../medias/boardPic/2022/Infineon/CapCanshu.png" alt="CapSense 原始计数与CapSense硬件参数间的关系"></p><p>Sigma-delta转换器每次扫描一个传感器。模拟复用器选择一个GPIO单元，并将其连接至Sigma-delta转换器的输入端，AMUXBUS  A和GPIO单元开关共同组成该模拟复用器。AMUXBUS A连接至支持CapSense功能的所有GPIO。AMUXBUS A还将集成电容CMOD连接至Sigma-delta转换器电路。<strong>AMUXBUS B用于屏蔽，并使能屏蔽时保持为VREF。</strong> </p><p>PSoC 4和PSoC 6 MCU CapSense支持用于防水和接近感应性能的屏蔽电极。CapSense具有一个屏蔽电路，该电路会使用传感器开关信号的副本来驱动屏蔽电极，这样可以避免传感器与屏蔽电极间潜在的差异。</p><h3 id="CapSense-CSX感应方式"><a href="#CapSense-CSX感应方式" class="headerlink" title="CapSense CSX感应方式"></a>CapSense CSX感应方式</h3><p>CSX感应方法用于测量Tx电极和Rx电极间的互电容，如下图所示。Tx电极是由数字波形（Tx时钟）激发的，该波形在VDDIO（如果VDDIO不可用，则使用VDDD）和接地间进行切换。Rx电极被静态连接到AMUXBUS A。CSX方法要求使用两个外部集成电容，CINTA 和CINTB。</p><p><img src="../../../../../medias/boardPic/2022/Infineon/CSXGanying.png" alt="CSX 感应波形"></p><p>通过调制器时钟，可以测量到在一个Tx时钟周期内对外部电容进行充电/放电所需的时间。因此，调制器时钟频率必须始终大于Tx时钟频率；调制器时钟的频率越高，准确度也越高。为了正常工作，需要设置IDAC电流，使CINTA 和CINTB 电容能在一个Tx时钟周期内完成充电或放电。CapSense组件提供了一个自动校准IDAC的选项。建议使能该选项。 </p><p><img src="../../../../../medias/boardPic/2022/Infineon/HuDianrong.png" alt="原始计数与互电容感应间的关系"></p><p>其中：<br>IDAC — IDAC电流<br>CM — Tx和Rx电极间的互电容<br>VTX — Tx信号幅度<br>FTX – Tx时钟频率<br>FMod – 调制器时钟频率<br>NSub − 子转换次数   </p><p>将手指放在CSX按钮上时，Rx和Tx电极间的互电容将被减小，同时降低原始计数。从硬件获取的原始计数由CapSense组件处理，以增加触摸事件的计数（类似于CSD中的计数）。</p><h3 id="PSoC-Creator-CapSesense"><a href="#PSoC-Creator-CapSesense" class="headerlink" title="PSoC Creator CapSesense"></a>PSoC Creator CapSesense</h3><p>打开默认工程：CE220891</p><p><img src="../../../../../medias/boardPic/2022/Infineon/Capex.png" alt="CapSense实验"></p><p>关于触摸按键、滑条的设置可以查看CapSense组件的配置，注意右侧添加的EZI2C组件，与仿真器相连，通过USB转I2C与电脑相连，其中配置的波特率为400kbps，只有一个地址，Slave地址为0x08，SubAddress为16bit。</p><p>在CapSense组件右键选择Launch Tuner，可打开触摸调试的可视化界面：</p><p><img src="../../../../../medias/boardPic/2022/Infineon/SenseTuner.png" alt="CapSense Tuner"></p><p>连接时按I2C Slave的参数配置填入即可，当手指按下后可以看见Raw Count和BaseLine的变化。</p><p>后续继续补充相关参数的配置说明。</p>]]></content>
      
      
      <categories>
          
          <category> Infineon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
            <tag> PSoC </tag>
            
            <tag> Touch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PSoC 4100S Architecure TRM</title>
      <link href="/2022/06/28/PSoC4/PSoC4CH2/"/>
      <url>/2022/06/28/PSoC4/PSoC4CH2/</url>
      
        <content type="html"><![CDATA[<h3 id="PSoC-4100S-Architecure-TRM"><a href="#PSoC-4100S-Architecure-TRM" class="headerlink" title="PSoC 4100S Architecure TRM"></a>PSoC 4100S Architecure TRM</h3><p>先从它的Architecure开始学起，参考文档：</p><p>Infineon-PSoC_4100S_and_PSoC_4100S_Plus_PSoC_4_Architecture_TRM-AdditionalTechnicalInformation-v12_00-EN.pdf</p><h3 id="CPU-System"><a href="#CPU-System" class="headerlink" title="CPU System"></a>CPU System</h3><ul><li>Cortex m0+ 32bit MCU，高达0.9DMIPS/MHz。</li><li>NVIC、MPU、VTOR</li><li>Address Map</li></ul><table><thead><tr><th align="center">Range</th><th align="center">Name</th><th align="center">Use</th></tr></thead><tbody><tr><td align="center">0x00000000 ~ 0x1FFFFFFF</td><td align="center">Code</td><td align="center">程序运行区，也可以存放数据，包含放于0起始地址的中断向量表</td></tr><tr><td align="center">0x20000000 ~ 0x3FFFFFFF</td><td align="center">SRAM</td><td align="center">SRAM区，也可以在此执行程序</td></tr><tr><td align="center">0x40000000 ~ 0x5FFFFFFF</td><td align="center">外设</td><td align="center">所有的外设寄存器地址</td></tr><tr><td align="center">0x60000000 ~ 0xDFFFFFFF</td><td align="center"></td><td align="center">未使用</td></tr><tr><td align="center">0xE0000000 ~ 0xE00FFFFF</td><td align="center">PPB</td><td align="center">CPU内核中的外设寄存器</td></tr><tr><td align="center">0xE0100000 ~ 0xFFFFFFFF</td><td align="center">Device</td><td align="center">PSoC4特殊寄存器</td></tr></tbody></table><ul><li><p>地址对齐访问：字对齐地址用于字或多字访问，半对齐用于半字访问，字节访问总是对齐的。</p></li><li><p>不支持CortexM0+处理器上的未对齐访问，任何尝试执行未对齐的内存访问都会导致Hardfault异常。<br>非对齐访问的定义：当试图从一个不被N偶数整除的地址（即addr % N != 0）开始读取N字节的数据时，就 会发生非对齐内存访问。例如，从地址0x10004读取4个字节的数据是可以的，但<strong>从地址 0x10005读取4个字节的数据将是一个不对齐的内存访问</strong>。</p></li><li><p>小端格式，little-endian</p></li></ul><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>DMA控制器仅在PSoC 4100S Plus器件中支持。有如下特性：</p><ul><li>支持八个通道，每通道可设四个优先级，每通道支持三种模式。</li><li>支持字节、半字（2B）和字（4B）传输</li><li>可配置中断，传输完成后可触发中断。</li><li>传输最大65535数据元素，可以是8bit、16bit或32bit。</li></ul><p>三种模式分：</p><ul><li>Mode 0: Single data element per trigger</li><li>Mode 1: All data elements per trigger</li><li>Mode 2: All data elements per trigger and automatically trigger chainned descriptor.</li></ul><p>具体请查看TRM手册。</p><h3 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h3><p>PSoC4支持Interrupts和Exceptions，Interrupt指由外设向CPU产生的事件，如timer、SCB（serial communication block）、GPIO等，Exception是由CPU产生的事件，如内存访问错误、内部timer事件等。中断和异常都会导致当前程序流停止并且 CPU 正在执行异常处理程序或中断服务例程 (ISR)。 PSoC4为中断处理程序/ISR 和异常处理程序提供了一个统一的异常向量表。特性：</p><p>支持32个中断</p><ul><li>Nested vectored interrupt controller (NVIC) 与 CPU 内核集成，产生低中断延迟</li><li>中断向量表可以放置在Flash或 SRAM 中</li><li>每个中断的可配置优先级从 0 到 3</li><li>电平触发和脉冲触发中断信号</li></ul><p><img src="../../../../../medias/boardPic/2022/Infineon/interrupt.png" alt="Level and Pulse interrupts"><br><img src="../../../../../medias/boardPic/2022/Infineon/VectorTable.png" alt="VectorTable"><br>第一个4字节用于芯片在复位时初始化主堆栈指针（MSP）值。通过修改VTOR，向量表可以位于Flash或SRAM中的任何位置，该寄存器位于0xE000ED08系统控制空间的一部分，占用31:8位，位7:0被保留。所以向量表地址应为<strong>256字节对齐</strong>！</p><p>除非 CPUSS_SYSREQ 寄存器的 DIS_RESET_VECT_REL 位置位，否则读取闪存地址 0x00000000 和 0x00000004 将重定向到 SROM 的前 8 个字节以获取堆栈指针和复位向量。 复位时该位的默认值为 0，确保始终从 SROM 获取复位向量。 要允许从地址 0x00000000 和 0x00000004 读取闪存，应将 DIS_RESET_VECT_REL 位设置为“1”。 堆栈指针向量保存堆栈指针在复位时加载的地址。 复位向量保存引导序列的地址。 完成此映射以在释放器件复位时使用来自 SROM 的堆栈指针和复位向量的默认地址。对于复位，首先执行 SROM 中的引导代码，然后 CPU 跳转到闪存中的地址 0x00000004 以执行闪存中的处理程序。 SRAM 向量表中的复位异常地址从不使用。</p><p>此外，当 CPUSS_SYSREQ 寄存器的 SYSCALL_REQ 位置位时，闪存地址 0x00000008 的读取将重定向到 SROM 以获取 NMI 向量地址，而不是从闪存中获取。 重置 CPUSS_SYSREQ 以读取地址 0x00000008 处的闪存。</p><p><strong>Supervisor Call (SVCall) Exception &amp; PendSV Exception</strong></p><p>主管调用 (SVCall) 是当 CPU 将 SVC 指令作为应用程序代码的一部分执行时引起的始终启用的异常。 应用软件使用 SVC 指令调用底层操作系统并提供服务。</p><p>PendSV 是另一个与 SVCall 类似的与主管调用相关的异常，通常是由软件生成的。 PendSV 始终处于启用状态，并且其优先级是可配置的。 通过设置中断控制状态寄存器 CM0P_ICSR 中的 PENDSVSET 位来触发 PendSV 异常。 设置该位后，PendSV 异常进入挂起状态，并等待 CPU 处理。 通过设置中断控制状态寄存器 CM0P_ICSR 中的 PENDSVCLR 位可以清除 PendSV 异常的挂起状态。 通过写入系统处理程序优先级寄存器 3 (CM0P_SHPR3) 的两个位字段 PRI_14[23:22]，可以将 PendSV 异常的优先级配置为 0 和 3 之间的值。</p><p><strong>中断优先级</strong></p><p>Reset、NMI和HardFault异常固定优先级分别为-3、-2、-1，其他中断可以配置为0~3，<strong>较低的数字代表较高的优先级。</strong>PSoC4支持中断嵌套，较高优先级的异常会阻碍（中断）当前低优先级的中断处理，如果优先级相同，则不会发生抢占。CPU处理完高优先级的中断后处理低优先级的异常处理。PSoC4的CM0+最多支持<strong>四个</strong>嵌套异常。</p><h3 id="Device-Security"><a href="#Device-Security" class="headerlink" title="Device Security"></a>Device Security</h3><p>PSoC® 4 提供了许多选项来保护用户设计免受未经授权的访问或复制。禁用调试功能并启用闪存保护可提供高级别的安全性。调试电路默认启用，只能在固件中禁用。如果禁用，重新启用它们的唯一方法是擦除整个flash，清除闪存保护，并使用启用调试的新固件重新编程设备。<br>注意：由于启用最大设备安全性时所有编程、调试和测试接口都被禁用，因此启用了完整设备安全性的 PSoC 4 设备可能不会被退回以进行故障分析。</p><p>CPU 以普通用户模式或特权模式运行，以BOOT、OPEN、PROTECTED 和 KILL四种保护模式之一运行。可以通过写入 CPUSS_PROTECTION 寄存器来更改模式。</p><p>■ BOOT 模式：设备在BOOT 模式下退出复位。它一直保持在那里，直到其保护状态从管理器闪存复制到保护控制寄存器 (CPUSS_PROTECTION)。在此期间调试端口访问停止。 BOOT 是一种将器件设置为其配置的保护状态所需的暂时模式。在 BOOT 模式期间，CPU 始终以特权模式运行。<br>■ OPEN 模式：这是出厂默认设置。 CPU 可以在用户模式或特权模式下运行。在用户模式下，可以对闪存进行编程并支持调试器功能。在特权模式下，强制执行访问限制。<br>■ PROTECTED 模式：用户可以将模式从OPEN 更改为PROTECTED。此模式禁用对用户代码或内存的所有调试访问。在保护模式下，只有少数寄存器可以访问；无法对寄存器进行调试访问以重新编程闪存。该模式可以重新设置为 OPEN，但只有在完全擦除Flash之后。<br>■ KILL 模式：用户可以将模式从OPEN 更改为KILL。此模式会删除对用户代码或内存的所有调试访问，并且无法擦除闪存。仍然可以访问大多数寄存器；无法对寄存器进行调试访问以重新编程闪存。器件不能退出 KILL 模式；处于 KILL 模式的设备可能不会返回以进行故障分析。</p><p>Flash按行进行组织，可以为每一行设置两种保护级别（Unprotected和Full Protection）的一种。</p><table><thead><tr><th><strong>Protection Setting</strong></th><th><strong>Allowed</strong></th><th><strong>Not Allowed</strong></th></tr></thead><tbody><tr><td>Unprotected</td><td>External read and write ，Internal read and write</td><td>~</td></tr><tr><td>Full Protection</td><td>External read ， Internal read</td><td>External write,Internal write</td></tr></tbody></table><p>The flash accel-erator delivers 85 percent of  single-cycle SRAM access per-formance on an average.</p><p>闪存加速器平均可提供 85% 的单周期 SRAM 访问性能。后续补充Flash 操作的API函数</p><h3 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h3><p>PSoC4 GPIO特性如下：</p><ul><li>模拟量和数字的IO输入输出。</li><li>八种驱动能力模式，低速率控制</li><li>上升沿、下降沿或两个沿上的边沿触发中断。</li><li>用于锁定先前状态的保持模式（用于在 Deep-Sleep 模式下保持 I/O 状态）</li><li>可选 CMOS 和低压 LVTTL 输入缓冲模式</li><li>CapSense 支持、段式LCD驱动支持</li><li>智能 I/O 块提供在 I/O 信号路径中执行布尔函数的能力</li><li>两条模拟多路复用器总线（AMUXBUS-A 和 AMUXBUS-B），可用于多路复用模拟信号</li></ul><p>GPIO 引脚连接到 I/O 单元。 这些单元配备了用于数字输入的输入缓冲器，为数字输出信号提供高输入阻抗和驱动器。 数字外设通过高速 I/O 矩阵 (HSIOM) 连接到 I/O 单元。 HSIOM 包含多路复用器，用于连接用户选择的外设和引脚。 一些端口引脚在 HSIOM 和引脚之间有一个 Smart I/O 模块。 Smart I/O 模块可以对引脚信号进行逻辑操作。 模拟外设和模拟多路复用器总线连接直接在 GPIO 单元中完成。 CapSense 模块通过 AMUX 总线连接到 GPIO 引脚。</p><p><img src="../../../../../medias/boardPic/2022/Infineon/GPIO.png" alt="GPIO"></p><p><img src="../../../../../medias/boardPic/2022/Infineon/GPIOPin.png" alt="GPIOPin"></p><h4 id="Digital-Input-Buffer"><a href="#Digital-Input-Buffer" class="headerlink" title="Digital Input Buffer"></a>Digital Input Buffer</h4><p>Digital Input Buffer对外部数字输入提供高阻缓冲，通过配置GPIO_PRTx_PC2寄存器的PORT_VTRIP_SEL位使能或禁用缓冲功能。buffer可以配置为<strong>CMOS和LVTTL</strong>模式。每种模式的阈值可以从数据表中获得。输入缓冲器的输出连接到 HSIOM，用于路由到选定的外设。</p><h4 id="Digital-Output-Driver"><a href="#Digital-Output-Driver" class="headerlink" title="Digital Output Driver"></a>Digital Output Driver</h4><p>在 PSoC4100S 中，I/O 由 VDDD 电源驱动。 每个 GPIO 引脚都有 ESD 二极管，用于将引脚电压钳位到 VDDD 源。 确保引脚上的电压不超过 I/O 电源电压 VDDD 并低于 VSSD。 有关绝对最大和最小 GPIO 电压，请参阅 PSoC 4100S 数据表。 可以使用来自与输出引脚相关的外设或数据寄存器 (GPIO_PRTx_DR) 的 DSI 信号来启用和禁用数字输出驱动器。 </p><p><img src="../../../../../medias/boardPic/2022/Infineon/IOOut.png" alt="IOOut"></p><p>■ 高阻抗模拟 High-impedance analog mode<br>高阻模拟模式为默认复位状态； 输出驱动器和数字输入缓冲器都关闭。 <strong>此状态可防止外部电压导致电流流入数字输入缓冲器。</strong> 对于浮动或支持模拟电压的引脚，建议使用此驱动模式。 高阻抗模拟引脚不能用于数字输入。 无论数据寄存器值如何，读取引脚状态寄存器都会返回 0x00。 <strong>为了在低功耗模式下实现最低的器件电流，必须将未使用的 GPIO 配置为高阻抗模拟模式。</strong></p><p>■ 高阻抗数字 High-Impedance Digital<br>高阻抗数字模式是推荐用于数字输入的标准高阻抗 (High Z) 状态。 在这种状态下，输入缓冲器为数字输入信号启用。</p><p>■ 电阻上拉或电阻下拉 Resistive Pull-Up or Resistive Pull-Down<br>电阻模式在其中一种数据状态下提供串联电阻，在另一种数据状态下提供强驱动。 在这些模式下，引脚可用于数字输入或数字输出。 如果需要电阻上拉，则必须将“1”写入该引脚的数据寄存器位。 如果需要电阻下拉，则必须将“0”写入该引脚的数据寄存器。 连接机械开关是这些驱动模式的常见应用。 电阻模式也用于连接 PSoC 与开漏驱动线。 当输入为开漏低电平时使用电阻上拉，当输入为开漏高电平时使用电阻下拉。 </p><p>■ 开漏驱动高电平和开漏驱动低电平 Open Drain Drives High and Open Drain Drives Low</p><p>开漏模式在其中一种数据状态下提供高阻抗，在另一种数据状态下提供强驱动。 在这些模式下，引脚可用作数字输入或输出。 因此，这些模式被广泛应用于双向数字通信中。 当信号被外部拉低时使用开漏驱动高模式，当信号被外部拉高时使用开漏驱动低。 开漏驱动低模式的常见应用是驱动 I2C 总线信号线。</p><p>■ 强驱动 Strong Drive<br>强驱动模式是引脚的标准数字输出模式； 它在高电平和低电平状态下都提供强大的 CMOS 输出驱动。 <strong>正常情况下，不得将强驱动模式引脚用作输入。</strong> 这种模式通常用于数字输出信号或驱动外部晶体管。</p><p>■ 电阻上拉和电阻下拉 Resistive Pull-Up and Resistive Pull-Down<br>在电阻上拉和阻性下拉模式下，GPIO 在逻辑 1 和逻辑 0 输出状态下都会有一个串联电阻。 高数据状态被拉高，而低数据状态被拉低。 当总线由可能导致短路的其他信号驱动时使用此模式。</p><h4 id="Slew-Rate-Control"><a href="#Slew-Rate-Control" class="headerlink" title="Slew Rate Control"></a>Slew Rate Control</h4><p>GPIO 引脚在强驱动模式下具有快慢输出压摆率选项； 这使用端口配置寄存器 (GPIO_PRTx_PC[25]) 的 PORT_SLOW 位进行配置。 每个端口的转换速率可单独配置。 该位默认清零，端口工作在快速转换模式。 如果需要慢速摆率，可以设置该位。 <strong>较慢的压摆率会降低 EMI 和串扰； 因此，对于低频信号或没有严格时序限制的信号，建议使用慢速选项。</strong></p><h4 id="High-Speed-I-O-Matrix"><a href="#High-Speed-I-O-Matrix" class="headerlink" title="High-Speed I/O Matrix"></a>High-Speed I/O Matrix</h4><p>高速 I/O 矩阵 (HSIOM) 是一组高速开关，可将 GPIO 路由到设备内部的外围设备。 由于 GPIO 被多个功能共享，HSIOM 复用引脚并连接到用户选择的特定外设。 在 PSoC 4100S 中，智能 I/O 模块将端口 2 和端口 3 引脚桥接到 HSIOM。 在 PSoC 4100S Plus 中，除了端口 2 和端口 3 外，<strong>端口 1 还支持Smart I/O 功能</strong>。 其他端口直接连接到 HSIOM。提供 HSIOM_PORT_SELx 寄存器来选择外设。 它是一个可用于每个端口的 32 位宽寄存器，每个引脚占用 4 位。 该寄存器为一个引脚提供多达 16 个不同的选项.</p><h3 id="Smart-I-O"><a href="#Smart-I-O" class="headerlink" title="Smart I/O"></a>Smart I/O</h3><p>Smart I/O 模块将可编程逻辑添加到 I/O 端口。 该可编程逻辑将 AND、OR 和 XOR 等板级布尔逻辑功能集成到端口中。 Smart I/O 模块具有以下特性：<br>■ 将板级布尔逻辑功能集成到端口中<br>■ 能够预处理来自 GPIO 端口引脚的 HSIOM 输入信号<br>■ 能够对 GPIO 端口引脚的 HSIOM 输出信号进行后处理<br>■ 支持所有设备电源模式 Support in all device power modes<br>■ 靠近 I/O pads集成，提供具有可编程性的最短信号路径<br>PSoC 4100S 器件支持两个端口（端口 2 和端口 3）上的Smart  I/O，而 <strong>PSoC 4100S Plus 器件支持三个端口（端口 1、端口 2 和端口 3）上的Smart  I/O。</strong></p><p>寄存器命名:  <strong>“PRGIO_PRT0”表示 端口 2 智能 I/O 寄存器</strong>，<strong>“PRGIO_PRT1”表示端口 3 智能 I/O 寄存器</strong>，<strong>PRGIO_PRT2 表示端口 1 智能 I/O 寄存器</strong>。 </p><p>Smart I/O 模块位于 HSIOM 和 I/O 端口之间的信号路径中。 HSIOM 将来自固定功能外设和 CPU 的输出信号多路复用到特定端口引脚，反之亦然。 智能 I/O 模块放置在此信号路径上，充当可以处理来自端口引脚和 HSIOM 的信号的桥，如图 8-4 所示。</p><p><img src="../../../../../medias/boardPic/2022/Infineon/SmartIO.png" alt="SmartIO"></p><h4 id="Block-Components"><a href="#Block-Components" class="headerlink" title="Block Components"></a>Block Components</h4><p>Smart I/O 的内部逻辑包括以下组件：<br>■ 时钟/复位组件<br>■ 同步器<br>■ LUT3 组件<br>■ 数据单元组件</p><h4 id="Clock-and-Reset"><a href="#Clock-and-Reset" class="headerlink" title="Clock and Reset"></a>Clock and Reset</h4><p>时钟和复位组件选择Smart I/O 模块的时钟 (clk_block) 和复位信号 (rst_block_n)。 单个时钟和复位信号用于块中的所有组件。 时钟和复位源由 PRGIO_PRTx_CTL 寄存器的 CLOCK_SRC[4:0] 位域确定。 所选时钟用于模块组件中的同步逻辑，其中包括 I/O 输入同步器、LUT 和数据单元组件。 选定的复位用于异步复位 LUT 和数据单元组件中的同步逻辑。</p><p>请注意，<strong>即使运行在同一时钟，模块同步逻辑的选定时钟 (clk_block) 与器件中的其他同步逻辑相位不对齐</strong>。因此，<strong>Smart I/O 与其他同步逻辑之间的通信应视为异步</strong>。</p><p>以下时钟源可供选择：<br>■ GPIO 输入信号“io_data_in[7:0]”。这些时钟源没有相关的复位。<br>■ HSIOM 输出信号“chip_data[7:0]”。这些时钟源没有相关的复位。<br>■ Smart I/O 时钟(clk_prgio) 是使用外设时钟分频器从系统时钟(clk_sys) 中获得的。该时钟仅在Active and Sleep power模式下可用。时钟可以选择两个相关的复位之一：rst_sys_act_n 和 rst_sys_dpslp_n。这些复位决定了模块同步状态在哪些系统电源模式下被复位；例如，rst_sys_act_n 旨在用于活动电源模式下的智能 I/O 同步功能，并在深度睡眠电源模式下激活复位。</p><p>■ 低频(40 kHz) 系统时钟(clk_lf)。该时钟在 Deep-Sleep 功耗模式下可用。这个时钟有一个相关的复位，rst_lf_dpslp_n。<br>当模块被使能时，选定的时钟 (clk_block) 和相关的复位 (rst_block_n) 被释放到结构组件。当被禁用时，不会向结构组件释放时钟并激活复位（LUT 和数据单元组件设置为复位值“0”）。</p><p> Clock and Reset Register Control</p><table><thead><tr><th><strong>Register[BIT_POS]</strong></th><th><strong>Bit Name</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>PRGIO_PRT0_CTL[12:8]</td><td>CLK_SRC[4:0]</td><td>时钟（clk_block）/复位（rst_block_n）源选择：<br/>“0”：io_data_in[0]/‘1’<br/>…<br/>“7”：io_data_in[7]/‘1’<br/>“8”：芯片数据[0]/‘1’<br/>…<br/>“15”：芯片数据[7]/‘1’<br/>“16”：clk_prgio/rst_sys_act_n；在除 Active 之外的任何电源模式下断言复位；即，Smart I/O 仅在使用来自外设分频器的时钟的主动电源模式下有效。<br/>“17”：clk_prgio/rst_sys_dpslp_n。智能 I/O 在所有电源模式下都处于活动状态，时钟来自外设分频器。但是，时钟在 Deep-Sleep 功耗模式下不会激活。 <br/>“19”：clk_lf/rst_lf_dpslp_n。智能 I/O 在所有电源模式下都处于活动状态，时钟来自 ILO。<br/>“20”-“30”：时钟源为常数“0”。当 IP 被禁用时，应选择这些时钟源中的任何一个，以确保低功耗。<br/>“31”：clk_sys/‘1’。此选择不适用于“clk_sys”操作。但是，对于异步操作，在启用 IP 三个“clk_sys”周期后，IP 将完全正常工作（复位被取消激活）。用于异步（无时钟）块功能。</td></tr></tbody></table><p>I/O 输入同步器引入了两个 clk_block 周期的延迟（当同步器被启用时）。 结果，在前两个周期中，the block may be exposed to stale data from the synchronizer output. 。 因此，在前两个时钟周期内，复位被激活并且模块处于旁路模式。</p><h4 id="Synchronizer"><a href="#Synchronizer" class="headerlink" title="Synchronizer"></a>Synchronizer</h4><p>每个 GPIO 输入信号和设备输入信号（HSIOM 输入）都可以异步或同步使用。 为了同步使用信号，如图 8-5 所示，在这两个信号路径上放置了一个双触发器同步器，以将信号与智能 I/O 时钟 (clk_block) 同步。 通过设置或清除 PRGIO_PRT0_SYNC_CTL 寄存器中 GPIO 输入信号的 IO_SYNC_EN[i] 位字段和 HSIOM 信号的 CHIP_SYNC_EN[i] 位字段来启用或禁用每个引脚/输入的同步，其中“i”是引脚号。</p>]]></content>
      
      
      <categories>
          
          <category> Infineon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
            <tag> BLE </tag>
            
            <tag> PSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PSoC 4100S Plus Start1</title>
      <link href="/2022/06/25/PSoC4/PSoC4CH1/"/>
      <url>/2022/06/25/PSoC4/PSoC4CH1/</url>
      
        <content type="html"><![CDATA[<h3 id="初识-PSoC-4"><a href="#初识-PSoC-4" class="headerlink" title="初识 PSoC 4"></a>初识 PSoC 4</h3><p>最近有幸得到了两块PSoC4的Demo板：<strong>CY8CKIT-149 PSoC 4100S Plus Prototyping Kit</strong> , 小白从零开始搞起，先上板子靓照：<br>  <img src="../../../../../medias/boardPic/2022/Infineon/CY8CKit.png" alt="CY8CKIT Board"></p><ol><li>官网 <a href="https://www.infineon.com/" target="_blank" rel="noopener">https://www.infineon.com/</a> 查找并下载相关资料，直接搜索CY8CKIT-149即可，相关资料都可以下载到了。文末提供百度盘的下载链接。<br><img src="../../../../../medias/boardPic/2022/Infineon/CY8CKITSource.png" alt="CY8CKIT Source"><br>先看原理图、功能框图及芯片：<strong>CY8C4147AZI-S475</strong> ，再啃啃Guide-UserManual，<br><img src="../../../../../medias/boardPic/2022/Infineon/gongnengtu.png" alt="SCH">  </li><li>下载并安装 PSoC™ Creator ：             <a href="https://softwaretools.infineon.com/tools/com.ifx.tb.tool.psoccreator" target="_blank" rel="noopener">https://softwaretools.infineon.com/tools/com.ifx.tb.tool.psoccreator</a></li><li>板卡插入USB线并连接PC后，会识别出xx的设备，此时板卡上的蓝色呼吸灯会有呼吸的效果，触摸不同的按键及滑条会有相应的指示灯点亮，效果还是很棒的。<br>PS：如果插入没有识别出USB设备，<strong>请检查USB线，可能它只支持充电而没有通信的功能</strong>。</li></ol><h3 id="PSoC-4100S-Plus："><a href="#PSoC-4100S-Plus：" class="headerlink" title="PSoC 4100S Plus："></a>PSoC 4100S Plus：</h3><ol><li>芯片资源：</li></ol><ul><li>48MHz Cortex-M0+，单周期乘法指令，SWD调试</li><li>16KB SRAM、128K Flash（读取加速）</li><li>8通道 DMA</li><li>12bit，1Msps SAR ADC，支持差分、单端和具有信号求平均功能的通道序列发生器。</li><li>由电容式感应模块提供的单斜10位ADC功能。</li><li>可用在任何引脚上的两个电流DAC（IDAC），用于通用目的或电容感应应用场合。</li><li>可在深度睡眠模式下工作的两个低功耗比较器</li><li><strong>Smart I/O</strong>：可编程逻辑模块支持在输入和输出端口上执行Boolean（布尔）操作</li><li>电压工作范围：<strong>1.71V~5.5V</strong>，深度睡眠模式可支持模拟系统正常工作，并为数字系统提供<strong>2.5uA</strong>电流。</li><li>电容式感应：CapSense Sigma-Delta（CSD）信噪比（SNR）（<strong>&gt;5:1</strong>）, 支持防水性能，支持自动硬件调节（SmartSense™）</li><li>GPIO上的LCD Segment驱动能力 （段码屏）</li><li>五个运行时可重新配置的独立串行通信模块（SCB），可配置为I2C、SPI或UART功能。</li><li>八个16位定时器/计数器/脉冲宽度调制器（TCPWM）</li><li>4至33MHz外部晶振（ECO），PLL生成48MHz，32KHz监视晶振（WCO），±2% 精度内部主振荡器 (IMO) ，32 kHz内部低速振荡器 (ILO)  .<br>PS: The WCO is a 32-kHz watch crystal oscillator. It is used to dynamically trim the IMO to an accuracy of ±1 percent to enable precision timing applications.</li><li>真随机数生成器（TRNG），为加密应用生成用于安全秘钥的真随机数</li><li>CAN 2.0 B，支持时间触发CAN（TTCAN）</li></ul><ol start="2"><li>电源：内部逻辑部分为<strong>1.8V</strong>，</li></ol><ul><li>模式一： 由外部电源供电，输入范围为<strong>1.8V ~ 5.5V</strong>，如使用开始为3.5V然后下降到1.8V的电池系统供电，此时，PSoC 4100S Plus内部调节器为内部逻辑供电，并且它的输出与VCCD引脚连接。VCCD引脚需要通过外部电容 (0.1 μF ；X5R 陶瓷或性能更好的电容)  旁路接地，并且不可连接到其他部分。</li><li><strong>1.8 V ± 5% 外部电源</strong> ：由一个电压范围为1.71 V 到1.89V 的外部电源供电；请注意，此范围必须包括了电源纹波。在该模式下，VDD和VCCD 引脚短接相连并被旁路。内部电压调节器可通过固件被禁用。 VDDD 需要通过旁路电容接地。通常并行选用一个1  μF 和一个0.1  μ F 的电容组。请注意，这只是简单的经验法则。</li><li>VIH和VOH：  <strong>VIH不能超过VDDD + 0.2 V</strong>  </li></ul><table><thead><tr><th align="center">规范ID</th><th align="center">参数</th><th align="center">说明</th><th align="center">最小值</th></tr></thead><tbody><tr><td align="center">SID57</td><td align="center">VIH</td><td align="center">输入最高电平阈值</td><td align="center">0.7 X VDDD</td></tr><tr><td align="center">SID241</td><td align="center">VIH</td><td align="center">LVTTL输入，VDDD&lt;2.7V</td><td align="center">0.7 X VDDD</td></tr><tr><td align="center">SID242</td><td align="center">VIH</td><td align="center">LVTTL输入，VDDD&gt;=2.7V</td><td align="center">2.0</td></tr><tr><td align="center">SID59</td><td align="center">VOH</td><td align="center">输出高电平</td><td align="center">VDDD-0.6</td></tr><tr><td align="center">SID60</td><td align="center">VOH</td><td align="center">输出高电平</td><td align="center">VDDD-0.5</td></tr></tbody></table><ul><li>上下拉电阻：最小：3.5kΩ，典型：5.6kΩ， 最大：8.5kΩ。输入漏电流最大：2nA。</li></ul><h3 id="PSoC-4100S-Plus原理图管脚分配："><a href="#PSoC-4100S-Plus原理图管脚分配：" class="headerlink" title="PSoC 4100S Plus原理图管脚分配："></a>PSoC 4100S Plus原理图管脚分配：</h3><ul><li><p><strong>IIC</strong>：P3_0 - I2C_SCL，P3_1 - I2C_SDA  同时连KitProg2与BLE。</p></li><li><p><strong>UART</strong>： P7_0 - U_RX，P7_1 - T_RX，与KitProg2相连，P5_1 - TX ，P5_0 - RX与BLE相连，电阻未放置。</p></li><li><p><strong>按键</strong>： P3_7 - SW1。 RESET_Key - SW2。</p></li><li><p><strong>LED</strong>: P3_4，高点亮。</p></li><li><p><strong>CapSense 按键 &amp; LED</strong>：P0_2 - TX，P4_6 - BTN0_RX(Big) / P5_2 - LED0 , P4_5 - BTN1_RX(Medium) / P5_5 - LED1 ,  P4_4 - BTN2_RX(Small) / P5_7 - LED2</p></li><li><p><strong>CapSense Slider &amp; LED</strong>:  P1_1 - Slider TX , P2_7 - Slider 0 RX / P2_2 - Slider 0 LED ,  P6_0 - Slider 1 RX / P2_0 - Slider 1 LED ,  P6_1 - Slider 2 RX / P1_6 - Slider 2 LED ,   P6_2 - Slider 3 RX / P1_4 - Slider 3 LED ,  P6_4 - Slider 4 RX / P1_2 - Slider 4 LED ,  P6_5 - Slider 5 RX / P1_0 - Slider 5 LED .</p></li></ul><h3 id="浅尝-PSoC-Creator开发环境"><a href="#浅尝-PSoC-Creator开发环境" class="headerlink" title="浅尝 PSoC Creator开发环境"></a>浅尝 PSoC Creator开发环境</h3><ol><li>安装好PSoC Creator 4.4并打开之，注册infineon的账号并填入。</li><li>确保板子上的SW4拨码拨至PSoC侧。KitProg2上的LED3会点亮。</li><li>打开例程：<strong>Start &gt; Kits &gt;  CY8CKIT-149</strong>，并选择存储位置。<br><img src="../../../../../medias/boardPic/2022/Infineon/PSoCCreator.png" alt="PSoC Creator Start"><br>顺便提一下，也可以用ModusToolBox开发，查找了下PSoC Creator和ModusToolBox对器件的支持：<br><img src="../../../../../medias/boardPic/2022/Infineon/IDESupport.png" alt="IDESupport"></li><li>在工程右键选择Build CE220891_CapSense_With_Breath_LED [CY8C4147AZI-S475] , 然后会生成相应的代码，编译、链接生成相应的文件，编译成功后，信息栏中会有如下提示：</li></ol><pre class=" language-bash"><code class="language-bash">Flash used: 15142 of 131072 bytes <span class="token punctuation">(</span>11.6%<span class="token punctuation">)</span>.SRAM used: 2944 of 16384 bytes <span class="token punctuation">(</span>18.0%<span class="token punctuation">)</span>. Stack: 2048 bytes. Heap: 128 bytes.--------------- Build Succeeded: 06/29/2022 19:13:54 ---------------</code></pre><ol start="5"><li>查看Build的信息栏发现：</li></ol><pre class=" language-bash"><code class="language-bash">--------------- Build Started: 06/29/2022 19:13:30 Project: CE220891_CapSense_with_Breathing_LED, Configuration: ARM GCC 5.4-2016-q2-update Debug ---------------cydsfit.exe -.appdatapath  <span class="token punctuation">..</span>. <span class="token punctuation">(</span>此处省略<span class="token punctuation">)</span>Elaborating Design<span class="token punctuation">..</span>.HDL Generation<span class="token punctuation">..</span>.Synthesis<span class="token punctuation">..</span>.Tech Mapping<span class="token punctuation">..</span>.Analog Placement<span class="token punctuation">..</span>.Analog Routing<span class="token punctuation">..</span>.Analog Code Generation<span class="token punctuation">..</span>.Digital Placement<span class="token punctuation">..</span>.Digital Routing<span class="token punctuation">..</span>.Bitstream Generation<span class="token punctuation">..</span>.Bitstream Verification<span class="token punctuation">..</span>.Static timing analysis<span class="token punctuation">..</span>.API Generation<span class="token punctuation">..</span>.Dependency Generation<span class="token punctuation">..</span>.Cleanup<span class="token punctuation">..</span>.</code></pre><p>如上HDL、Synthesis、Map、Bitstream等部分，貌似都是FPGA的开发流程，Smart I/O如是操作？？以后慢慢分析~</p><ol start="6"><li>然后选择Debug &gt; Program 或者按  Ctrl+ F5 ，会将生成的固件通过板载的KitProg2下载至PSoC4芯片中，信息栏提示：</li></ol><pre class=" language-bash"><code class="language-bash">Programming device <span class="token string">'PSoC 4100S Plus CY8C4147AZI-S475'</span> with <span class="token function">file</span> <span class="token string">'xxx.hex'</span><span class="token keyword">.</span>Device ID CheckErasing<span class="token punctuation">..</span>.Programming of Flash Starting<span class="token punctuation">..</span>.Protecting<span class="token punctuation">..</span>.Verify Checksum<span class="token punctuation">..</span>.Finished ProgrammingDevice <span class="token string">'PSoC 4100S Plus CY8C4147AZI-S475'</span> was successfully programmed at 06/29/2022 19:44:16.</code></pre><ol start="7"><li>所有生成的C代码位于项目选择的路径中，如下：<br>..\MyPSoC4P1\CE220891_CapSense_with_Breathing_LED\CE220891_CapSense_with_Breathing_LED.cydsn\Generated_Source\PSoC4<br>生成的hex文件位于：<br>..\MyPSoC4P1\CE220891_CapSense_with_Breathing_LED\CE220891_CapSense_with_Breathing_LED.cydsn\CortexM0p\ARM_GCC_541\Debug，有CE220891_CapSense_with_Breathing_LED.hex 和对应的map文件。</li></ol><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>至此，通过PSoC Creator运行板卡自带例程已完成。接下来慢慢分析其具体流程。与之相关的工具、文档等可从度盘下载：<br>链接: <a href="https://pan.baidu.com/s/1Wu4PtxFdc7bUDzSnz9oxZg?pwd=1234" target="_blank" rel="noopener">https://pan.baidu.com/s/1Wu4PtxFdc7bUDzSnz9oxZg?pwd=1234</a><br>提取码: 1234 </p><p>Enjoy it ~ 。</p>]]></content>
      
      
      <categories>
          
          <category> Infineon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
            <tag> BLE </tag>
            
            <tag> PSoC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MC3172初识</title>
      <link href="/2022/06/02/MC3172_C1/"/>
      <url>/2022/06/02/MC3172_C1/</url>
      
        <content type="html"><![CDATA[<p>2022年，疫情持续，缺芯的现况也持续，国产MCU如雨后春笋般应运而生，又发现了一国产神芯：<strong>MC3172</strong>，官网链接：<a href="http://www.gxchip.cn/" target="_blank" rel="noopener">http://www.gxchip.cn/</a> ， 芯片资源下载：<a href="https://gitee.com/gxchip" target="_blank" rel="noopener">https://gitee.com/gxchip</a></p><h3 id="芯片简介"><a href="#芯片简介" class="headerlink" title="芯片简介"></a>芯片简介</h3><ul><li>业内首个64线程同步并行运行，线程资源可按需配置，共享代码段空间与数据段空间，硬件级实时响应，无需中断服务程序，无需实时操作系统。</li><li>基于RISC-V RV32IMC 指令集，100%单周期指令，最高200MHz主频，3.37coremark/MHz。</li><li>数据段与代码段共享128K字节SRAM，可按需配置为96K代码空间加32K数据空间，或64K代码空间加64K数据空间，或32K代码空间加96K数据空间。</li><li>丰富片内外设：12个可配置通信接口，可按需配置为UASRT或SPI或USB或CAN总线形式，</li><li>6个双缓冲24位计数器，可提供高精度PWM与输入捕捉；</li><li>最高 200MHz 系统主频</li></ul><p>看上去还是蛮有特色的：<strong>64线程同步并行运行</strong>，文档中是这样描述的：<br>“ 并行多线程是一种全新的CPU工作模式与软件开发模式，不同于单线程裸机编程，只能顺序执行，也不同于操作系统通过切换造成的多线程执行，并行多线程的各个线程是一直在并行运行的，彼此互不打扰，没有优先级的概念，也没有切换的随机性。每个线程的运行速度和自己的栈空间都是可以按需配置的…”</p><p>虽然描述的是同步并行运行，不过单核MCU要实现此功能，还是有些怀疑，目前开放样板申请，于是赶紧申请了一块小板实测一下：</p><p>  <img src="../../../../medias/boardPic/2022/diy/MC3172Board.jpg" alt="MC3172 Board Pic"></p><p>收到demo板厚还是微微有些失望：板子看上去简单又复杂，简单的是连个led都没放，复杂的是排针都占满了，还是向上插的，想打个底板也只能扣上面了，而且左下角的排针还碍事… 不管怎样，先搞起来~</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>Mounriver Studio，嗯没错，沁恒的CH573、CH32V307等也都是用这个IDE搞开发的，国产芯，一家亲~<br>关于线程的配置，官方提供了一个图形化的配置工具，位于“MC3172资料合集_v1.12\MC3172_Template\MC3172 “ 目录下，运行即可配置。关于线程的描述如下：</p><ol><li>64个线程的运行速度，<strong>每个线程最高可以运行在主频的1/4</strong>，最低是主频的1/1024，不使用的线程可设置为空闲，空闲线程完全不运行，也不产生功耗。<strong>64个线程分属4个线程组，每个线程组的最高主频份额不能超过主频的1/4</strong>。</li><li>64个线程的运行栈空间，每个线程都有自己独立的栈空间，且在数据空间允许的范围内随意分配，只要所有非空闲线程的栈空间总和不超过数据空间的大小即可（数据空间有192字节的保留区不可使用），栈空间大小需要是4字节的整数倍。</li><li>代码空间和数据空间分配，MC3172拥有128K字节的存储器，可以按需分配为96K代码空间+32K数据空间，或64K代码空间+64K数据空间或32K代码空间+96K数据空间，客户根据自己的实际需要选择即可</li><li>时钟源选择，MC3172拥有4个时钟源，可在界面按需选择。</li></ol><p>配置完毕后，点击生成代码按钮即可得到thread_config.h和MC3172.lds两个文件。当运行配置工具尝试配置时：</p><p>  <img src="../../../../medias/boardPic/2022/diy/task.png" alt="线程配置"></p><p>大体上明白了：<strong>共4个线程组，每组最多占1/4主频，并且每组中线程加起来不得超过1/4主频。</strong></p><p>  MCU硬件层实现了1/4轮询调度，应该是类似时间片轮询的方式实现的吧，所以没有优先级的概念，硬件实现了线程切换、入栈及压栈。</p><p>装好MounRiver Studio后，双击MC3172.wvproj即可打开官方提供的例程：</p><p>  <img src="../../../../medias/boardPic/2022/diy/SampleCode.png" alt="MC3172_Template"></p><p>Ctrl + B可以编译之，程序也如板子一样简洁，连个点灯的参考程序都木的~ </p><p>编译完成后会生成MC3172.hex文件，此时可以打开 “开发板程序下载_v1.1.exe” 选择该文件将其下载进去。连接USB线后会识别为HID的GX_LINK，连接设备然后下载即可。</p><p>  <img src="../../../../medias/boardPic/2022/diy/MCDwn.png" alt="MCDwn"></p><p>目前Mounriver Studio IDE还不支持配置该工具直接下载及单步调试，坐等官方更新~</p><p>第一篇到此结束，接下来看看如何将其利用起来，比如可以搞上两个tft屏，两个线程分别用来刷屏~</p>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
            <tag> RISC-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CH32F207 &amp; V307</title>
      <link href="/2022/03/01/CH32F207&amp;V307/"/>
      <url>/2022/03/01/CH32F207&amp;V307/</url>
      
        <content type="html"><![CDATA[<p>2022年，疫情持续，缺芯的现况也持续，国产MCU如雨后春笋般应运而生，各种xx32F103/407xxx等打着兼容stm32的旗帜让人眼花缭乱，不知取舍，看了下WCH的官网突然发现了这颗神芯：<strong>CH32F207 / CH32V307</strong>:</p><ul><li>USB：一路内置高速PHY，一路OTG FS。</li><li>以太网：一路千M MAC，一路内置10M PHY。</li><li>CAN：两路CAN 2.0。</li><li>主频144MHz，256K FLash+64K Sram， 支持用户选择字配置为 <strong>192K FLash+128K Sram</strong> 、<strong>224K FLash+96K Sram</strong> 、<strong>256K FLash/64K Sram</strong>、<strong>288K FLash/32K Sram</strong>，（神奇的配置，用flash加速实现sram功能？？）</li><li>支持单周期乘法、硬件除法</li></ul><p>PS：查了下手册，CH32V307相比F207，有如下不同：</p><ul><li>CH32V307为Risc-V（V4F）核，F207为CortexM3核。</li><li>CH32V307支持硬件浮点（FPU）。</li><li>其他不同暂未发现 后续补充，V307只能用MounRiver Studio开发？？</li></ul><p>于是赶紧找WCH的Sale申请了样片，lay板子 …</p><p>  <img src="../../../../medias/boardPic/2022/diy/CH32F207.png" alt="CH32F207 Board Pic"></p><p>发现的一些美中不足之处：</p><ul><li>内置10M以太网PHY如果能换成100M就完美了。</li><li>CAN如果能支持CANFD就perfect了~</li><li>10M以太网接口与SDIO有两个PIN复用了，不可同时使用，这真是蛋疼的设计~ ~</li></ul><p>先使用CH32F207搞起，因为是CM3核支持Keil支持JLink开发，所以作为我的首发，结果发现WCH明显对CH32V307更加偏爱，从放出的例程包可以看出，F207的ETH文件夹为空，没法测试千M网了，连10M也没法测试了。。。</p><p>WCH的例程还是非常容易上手的，简单，简洁，尤其是USB的例程，简洁的令人发指~ ，SPI程序完全兼容STM32的配置，直接拿stm32的spi配置程序怼过来，接上tft就跑起来了，于是把最新的lvgl 8.3-dev 给移植过来了，结果发现跑benchmark就卡死在第82项测试上，换上lvgl-8.20 release版本就欢快的跑过了，</p><p>  <img src="../../../../medias/boardPic/2022/diy/lvglBenchmark.png" alt="CH32F207 Lvgl Benchmark"></p><p>LVGL功能越来越丰富，也越来越优秀，SPI 优化对于lvgl的加速还是明显的，尤其是disp_flush函数，不能使用简单的打点，换成窗口模式，只发送，快很多。SPI如果配置成DMA方式应该会加快很多。本想使用USB Host接个鼠标做输入设备，结果Host的例程又是少的可怜，坐等后期WCH更新例程后再行测试。 还有高速USB及以太网的测试，后续更新 敬请期待。</p>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DIY </tag>
            
            <tag> MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>F072 W5500 双以太网</title>
      <link href="/2021/12/22/F072W5500/"/>
      <url>/2021/12/22/F072W5500/</url>
      
        <content type="html"><![CDATA[<p>最近有个需求要使用简单的网络通信，速率要求并不高，只是按下按键通过UDP发送一包数据，本来想用407来做，后来还是想起了它：W5500，虽然N多年前就用KL27做过一个，不过板子早就找不到了，于是就用stm32f072又新做了一个：</p><p><img src="../../../../medias/boardPic/2022/diy/F072W5500.jpg" alt="F072W5500 Pic"></p><p>一片小小的STM32F072连接了如下：</p><ul><li><p>两个SPI连接了两个W5500，实现两路以太网，最多支持16个socket，互联互通。</p></li><li><p>一路CAN、一路RS485、一路RS232、一路串口TTL</p></li><li><p>USB（免晶振）、蓝牙（串口）</p></li><li><p>按键、LED</p><p>UDP 收发经过测试还是很不错的</p><p><img src="../../../../medias/boardPic/2022/diy/W5500UDP.jpg" alt="W5500UDP Pic"></p><p>CAN可以移植PCAN的程序（之前也已实现过了），这么一来，这个小板具有了丰富的功了。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> DIY </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DIY </tag>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TMC2226步进电机驱动</title>
      <link href="/2021/12/12/TMCS2226/"/>
      <url>/2021/12/12/TMCS2226/</url>
      
        <content type="html"><![CDATA[<p>最近搞了这个小玩意，STM32F072+TMC2226步进电机驱动，TMC2226在云汉芯城上的价格零售11元，难得的亲民，于是就打了个板测试一下：</p><p>效果超乎想象，出奇的静音：</p><p><img src="../../../../medias/boardPic/2022/diy/TMC2226.jpg" alt="TMC2226 Pic"></p><p><img src="../../../../medias/boardPic/2022/diy/TMC2226Motor.jpg" alt="TMC2226 Pic"></p><p>装在小盒子里很完美~（下面是42步进电机）。TMC2226的一些特性：</p><ul><li>静音防抖步进驱动，内置MOS，最高29V,峰值2.8A；</li><li>防堵转、电流自适应负载（节能高达75%）</li><li>脉冲/方向控制 8，16，32，64 细分硬件配置，UART配置最高256 细分 内部自带MicroPley</li><li>细分插补技术实现 256 细分输出，确保运行平滑</li><li>StealthChop2 静音驱动技术（低速超静音）</li><li>SpreadCycle 高动态性能电机斩波控制（高速防抖动）</li><li>Stallguard4 第四代同时适应 StealthChop 的负载力矩检测功能（防堵转）</li><li>Coolstep 电流随负载调节控制，可节能 75%（电流自适应）</li><li>低 RDSon，低温升。LS 170mΩ &amp; HS 170mΩ (typ. at 25°C)</li><li>低功耗待机适应 EUP 或电池供电应用</li><li>可选内部检测电阻，无需外置</li><li>单线 UART&amp;OTP 高级配置选项</li><li>等等 其他一些特性</li></ul>]]></content>
      
      
      <categories>
          
          <category> DIY </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DIY </tag>
            
            <tag> Motor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再来一波JLink</title>
      <link href="/2021/12/08/JLinkWifi/"/>
      <url>/2021/12/08/JLinkWifi/</url>
      
        <content type="html"><![CDATA[<h3 id="JLink-Wifi-Mini"><a href="#JLink-Wifi-Mini" class="headerlink" title="JLink Wifi Mini"></a>JLink Wifi Mini</h3><p>最近继续折腾JLink，JLink Wifi Mini版也来了~ ，硬是给赛进了这个小盒子里。。。</p><p><img src="../../../../medias/boardPic/2021/tools/JLinkWifi.jpg" alt="JLinkWifi Pic"></p><p>jcmder：</p><p><img src="../../../../medias/boardPic/2021/tools/JWificmd.png" alt="JLinkWifi Pic"></p><p>不知道西哥咋想的，选了这么一款蛋疼的WIFI模组，又贵又难买，选esp32多好。实测wifi信号也不咋地，路由器在客厅里，我在屋子里用它就连不上，后来想了个好主意，把它和我的mini路由器邦一块，用充电宝给它们供电，笔记本连路由器，就OK啦。</p><p><img src="../../../../medias/boardPic/2021/tools/JLinkWifiII.jpg" alt="JLinkWifi和路由器"></p><h3 id="Flasher-Portable-V1"><a href="#Flasher-Portable-V1" class="headerlink" title="Flasher Portable V1"></a>Flasher Portable V1</h3><p>Flasher Portable V1在Flasher 4的基础上，增加了多固件的支持，可以通过按键最多选择四个固件并以LED指示选择状态，支持电池供电并支持一键开关机。相比Flasher4没了以太网和串口控制功能，不管怎样还是值得一搞，于是便有了它：</p><p><img src="../../../../medias/boardPic/2021/tools/FlasherPortableV1.jpg" alt="Flasher Portable V1"></p><p>目前还没有boot，只有app，造了个跳转就跑起来了，为此改了个上位机用来查看文件、上传和下载文件。</p><p><img src="../../../../medias/boardPic/2021/tools/FlasherTool.png" alt="FlasherTool.png"></p><p>正如网友说的：都有奥迪（Flasher Portable Plus）了，还要这马车干嘛。。。生命的意义贵在折腾。</p><h3 id="FlasherWifiPlus"><a href="#FlasherWifiPlus" class="headerlink" title="FlasherWifiPlus"></a>FlasherWifiPlus</h3><p>之前把Flasher4的以太网插到无线路由器上，就实现了JLink Wifi的功能，于是就做了个小版的带屏带wifi、带两个以太网口的Flasher Wifi Plus：</p><p><img src="../../../../medias/boardPic/2021/tools/MyFlasherWifi.jpg" alt="FlasherWifiPlus"></p><p>加了个stm32f072用来通过串口烧写控制与显示，界面先简单的搞个。路由器核心板用的是MT7628/88的，之前三四十左右，现在也七八十了，物价飞涨啊</p><p>还没有完全的折腾完，先放上来秀一把。</p>]]></content>
      
      
      <categories>
          
          <category> TOOL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> JLink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WS2812 LED灯</title>
      <link href="/2021/12/02/WS2812Led/"/>
      <url>/2021/12/02/WS2812Led/</url>
      
        <content type="html"><![CDATA[<p>最近也DIY了个5050的灯板玩玩：</p><p><img src="../../../../medias/boardPic/2022/diy/ws2812P1.jpg" alt="WS2812 Pic"></p><ul><li>使用stm32f072控制，还是我曾经最喜欢用的48PIN MCU。</li><li>5V供电，手拉手串了16个。</li><li>SPI通信的方式，参考Arduino的库实现，可以玩出各种花。</li><li>加了个串口的蓝牙芯片，也可以手机控制打开、关闭、调光了</li></ul><p>点亮后的效果：</p><p><img src="../../../../medias/boardPic/2022/diy/ws2812P2.jpg" alt="WS2812 Pic"></p><p>亮度还是可以的，亮瞎眼~  给它套上个螺壳，非常漂亮。</p><p><img src="../../../../medias/boardPic/2022/diy/ws2812P3.jpg" alt="WS2812 Pic"></p><p>下一步准备把它固定到我的台灯上。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> DIY </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DIY </tag>
            
            <tag> MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重开一篇LPC4370</title>
      <link href="/2021/11/02/LPC4370/"/>
      <url>/2021/11/02/LPC4370/</url>
      
        <content type="html"><![CDATA[<p>在家整理芯片的时候翻出了这款神器：</p><p>NXP的三核MCU：一个CM4+两个CM0，204M主频，282KB SRAM，两路高速USB，SDRAM、LCD控制器、以太网、双CAN、QSPI Flash等等应有尽有，还有那强悍的<strong>SGPIO</strong>以及<strong>80Msps</strong> <strong>12bit</strong> ADC，秒天秒地秒空气神一般的存在，放眼望去，谁与争锋？又翻出了当时的板子及帖子：</p><p><img src="../../../../medias/boardPic/2021/pcb/LPC4370Core.png" alt="LPC4370Core Pic"></p><ul><li><p>板载32bit SDRAM / Nandflash / QSPI Flash</p></li><li><p>两路USB、两路CAN、 N路串口、LAN8720以太网PHY</p></li><li><p>24bit 最高1024*768分辨率 TFT驱动</p></li><li><p>12bit 80MSPS高速ADC，还有多路10bit的ADC。</p><p>刚好有个基于lpclinkII的开源应用：Labtools，当时还有开源的软件系统：RAW-OS，不知道是否还有人记得~  于是仿照着做了一个：</p><p><img src="../../../../medias/boardPic/2021/pcb/LPC4370LabTools.png" alt="MyLabtools Pic"></p><p><img src="../../../../medias/boardPic/2021/pcb/LPC4370BaseBoard22.png" alt="PCB Pic"></p></li></ul><p>先从TFT搞起：</p><h3 id="LCD-TFT-RGB565"><a href="#LCD-TFT-RGB565" class="headerlink" title="LCD-TFT RGB565"></a>LCD-TFT RGB565</h3><p>​    虽然引出了24bit的LCD，不过太占管脚，没有太实际的意义，而16bit RGB565格式的显示效果也还是不错的，65536色。关于LCD管脚应用，参考手册UM10503 P901描述如下：</p><p><img src="../../../../medias/boardPic/2021/pcb/PINConfig.png" alt="PINConfig Pic"></p><p>对于16bit 565格式的管脚配置，根据手册使用LCD_VD[3:7],LCD_VD[10:15],LCD_VD[19:23],未使用的LCD管脚均可配置为GPIO管脚或作它用。程序中管脚配置如下：</p><p><img src="../../../../medias/boardPic/2021/pcb/LCD_PinCfg.png" alt="LCDPinCfg Pic"></p><p>  LCD需要配置SDRAM做显存，默认地址是0x28000000，所以需要先调试SDRAM，保证读写正确及SDRAM的时序满足需求，配置起来需要对照着SDRAM数据手册来调整，比较讨厌的。对于图片取模，可以使用Image2LCD工具，如图设置：</p><p><img src="../../../../medias/boardPic/2021/pcb/Image2LCD.jpg" alt="Image2LCD Pic"></p><p>在5寸屏800*480 分辨率，显示效果如下：（PS：实际显示效果更加细腻！！）</p><p><img src="../../../../medias/boardPic/2021/pcb/LPC4370_LCD_PIC.png" alt="Image2LCD Pic"></p><h3 id="LCD-双缓存配置"><a href="#LCD-双缓存配置" class="headerlink" title="LCD-双缓存配置"></a>LCD-双缓存配置</h3><p>首先引用下单显存及双显存的解释：（个人感觉比较好）</p><p>​    在嵌入式平台Linux，主要通过framebuffer来显示UI。FrameBuffer实际上就是嵌入式系统中专门为GPU所保留的一块连续的物理内存，LCD通过专门的总线从framebuffer读取数据，显示到屏幕上。根据系统中framebuffer的数量，可以分成单buffer和双buffer两种。  …  不贴了</p><p>​    上面没有格式化的文字看上去很头疼，简单来说就是<strong>为了保持屏幕不闪烁而使用两块显存做显示切换，一块做当前的显示，需要更新显示的内容在第二块显存上做操作，完成后只需要将显存地址切换至第二块即可。好处不必多说，劣势也有：局部刷新时，显示内容的拷贝填充等，关键在于如何灵活运用。    同时还有一点需要注意的是：显存切换时需要在一屏刷新完成后切换！！！不然会有撕裂感。LCD中断寄存器：（BIT3）</strong></p><p><img src="../../../../medias/boardPic/2021/pcb/LCD_IT.png" alt="LCD_IT Pic"></p><p>  RT-Thread RealBoard-LPC4088已经实现了双显存的配置，使用时可以参考：</p><p><img src="../../../../medias/boardPic/2021/pcb/LCD_IT_Soft.png" alt="LCD_IT_Soft Pic"></p><h3 id="双缓存搞好就太监了，下面没有了"><a href="#双缓存搞好就太监了，下面没有了" class="headerlink" title="双缓存搞好就太监了，下面没有了~~"></a>双缓存搞好就太监了，下面没有了~~</h3>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
            <tag> CortexM4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA JLink OBF4-Arduino</title>
      <link href="/2021/10/21/IDAJlinkOBF4/"/>
      <url>/2021/10/21/IDAJlinkOBF4/</url>
      
        <content type="html"><![CDATA[<p>在7.56a版本的 Jlink dll里发现多了一个新的OB：J-Link_OB-STM32F4-Arduino_V1，到西哥网上浏了一圈也没找到相关信息，于是搞出来塞进IDA里分析了一下，发现初始化和F4的初始化函数：void SystemInit(void) 神似，Just LooK:<br><img src="../../../../medias/boardPic/2021/tools/IDAF4.png" alt="IDAF4 Pic"></p><p>注释是对照着函数、寄存器添加上的，IDA还没有那么智能<del>~</del></p><p>标黄部分为时钟配置，看上去貌似是6M晶振 - 84M主频，不管3721找个407的板子怂上一试先。</p><p>插上USB后听到了叮咚声却无法识别的USB设备，应该是时钟配置不正确，不是6M也是6的倍数，换个12M的试试，果然识别出JLink了~</p><p>接下来就是常归操作：设置序列号及add licenses：</p><p><img src="../../../../medias/boardPic/2021/tools/JOBF4.png" alt="IDAF4 Pic"></p><p>好开心，又成全功能版啦，尝试vcom enable命令，查看设备管理器，JLink的USB虚拟串口也出来了，剩下的管脚配置就不是事了，暂时不折腾了，估计比OB072性能强些吧。</p><p>或者某天就会遇到开源的STM32F4 Arduino的板子上载了这个OB。</p>]]></content>
      
      
      <categories>
          
          <category> TOOL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> JLink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NUC980 Linux 笔记</title>
      <link href="/2021/08/02/NUC980Note/"/>
      <url>/2021/08/02/NUC980Note/</url>
      
        <content type="html"><![CDATA[<p>N年前折腾过NUC972，可惜需要配个头又大管脚又多的Nand flash，后来它的弟弟NUC980诞生了，支持了QSPI Nand，但阉割掉了LCD控制器，也无所谓了，如果需要耍屏的话还可以其他方案了，全志的V3S、国产的SSD20x都是屏驱的好方案。赶着JLC支持免费的紫油及免费的4层PCB打样，就继续去薅他的羊毛~</p><p><img src="../../../../medias/boardPic/2021/tools/NUC980Board.jpg" alt="MyNUC980 Board"></p><p>调试的过程中也是遇坑无数，满眼都是泪…  比如uboot下以太网，不知道你们是否都能正常tftp，反正我是折腾了好久，对照着nuc972的网卡驱动改过来的，目前uboot下网络能正常运行，但是启动linux后，网络死活跑不起来，而另一块不是核心板的板子，同样的固件、同样的配置，网络跑的很欢快，丢包还是有的。真是无语了~</p><h3 id="烧写地址配置"><a href="#烧写地址配置" class="headerlink" title="烧写地址配置"></a>烧写地址配置</h3><p>Nuvoton NuWriter 下载、安装，选择SPI NAND</p><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">execute地址</th><th align="center">offset</th></tr></thead><tbody><tr><td align="center">SPL</td><td align="center">Loader</td><td align="center">200</td><td align="center">0</td></tr><tr><td align="center">uboot</td><td align="center">Data</td><td align="center"></td><td align="center">0x10000</td></tr><tr><td align="center">env</td><td align="center">Environment</td><td align="center"></td><td align="center">0x8000</td></tr><tr><td align="center">kernel(uImage)</td><td align="center">Data</td><td align="center"></td><td align="center">0x20000</td></tr><tr><td align="center">rootfs</td><td align="center">Data</td><td align="center"></td><td align="center">0x160000</td></tr></tbody></table><h3 id="Uboot"><a href="#Uboot" class="headerlink" title="Uboot"></a>Uboot</h3><ol><li><p>env的配置：（放txt里直接烧录到指定位置即可）<br>setenv ethaddr 08:55:00:11:66:88<br>setenv ipaddr 192.168.2.28<br>setenv serverip 192.168.2.21<br>setenv bootcmd sf probe 0 75000000;sf read 0x7fc0 0x200000 0x800000;bootm 0x7fc0<br>saveenv</p></li><li><p>uboot tftp启动内核：（windows下开tftp软件，配置目录，关闭防火墙）<br> tftpboot 0x7fc0 980uimage<br> bootm 0x7fc0</p></li></ol><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><ol><li><strong>取消ramfs文件系统</strong>，真是坑爹的骚操作。并配置：<br>noinitrd root=/dev/mtdblock2 rootfstype=yaffs2 rootflags=inband-tags rw console=ttyS0,115200n8 init=/sbin/init mem=64M rootwait=1 mtdparts=nand0:0x200000@0x0(u-boot),0x1400000@0x200000(kernel),-(user)</li><li>配置SPI时，取消quard模式，选择normal模式，奇葩的设置。</li><li>使能NFS文件系统。</li></ol><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ol><li>官方提供的文件系统傻傻的，命令弱的可怜，自己动手丰衣足食，使用busybox配置做文件系统即可，注意编译的时候不要选择static。可参考如下连接制作：<br><a href="https://blog.csdn.net/weixin_38387929/article/details/108538631" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38387929/article/details/108538631</a></li><li>生成busybox文件后，查看所依赖的库文件（没必要copy全部的库，太多太大了）<br>arm-linux-gnueabi-readelf -d busybox | grep NEEDED<br>或者：arm-linux-gnueabi-objdump -x busybox | grep NEEDED<br>将其所需要的库文件拷贝到根目录的lib文件下即可。注意有很多是连接文件，需要连同实际文件一起copy。一般只需要4个即可。</li><li>挂在NFS文件系统：<br>mount -t nfs -o intr,nolock,tcp,rsize=2048,wsize=1024 192.168.2.21:/ /mnt/nfs</li><li>busybox 显示用户名及路径：参考如下连接<br><a href="https://blog.csdn.net/litao31415/article/details/50188243" target="_blank" rel="noopener">https://blog.csdn.net/litao31415/article/details/50188243</a></li><li>网络调试工具：<strong>ethtool</strong>，新塘提供了，直接make即可，通过它可以看当前的网卡配置。貌似还有个mii-tool的工具，没用过。Linux网络命令mii-tool和ethtool使用参考连接：<br><a href="https://blog.csdn.net/yzhang6_10/article/details/81557195" target="_blank" rel="noopener">https://blog.csdn.net/yzhang6_10/article/details/81557195</a></li></ol><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ol><li>win10 WSL下cannot execute binary file: Exec format error:  - 安装QEMU<br>sudo apt update<br>sudo apt install qemu-user-static<br>sudo update-binfmts –install i386 /usr/bin/qemu-i386-static –magic ‘\x7fELF\x01\x01\x01\x03\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x03\x00\x01\x00\x00\x00’ –mask ‘\xff\xff\xff\xff\xff\xff\xff\xfc\xff\xff\xff\xff\xff\xff\xff\xff\xf8\xff\xff\xff\xff\xff\xff\xff’<br>sudo service binfmt-support start</li></ol>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nuvoton </tag>
            
            <tag> ARM9 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CH573F调试笔记 二 之编译调试与下载</title>
      <link href="/2021/07/28/CH573F02Debug/"/>
      <url>/2021/07/28/CH573F02Debug/</url>
      
        <content type="html"><![CDATA[<p>工欲善其事，必先利其器！快捷的仿真调试会事半功倍，反之则事倍功半。先给这个小板配个底板，把要调试的功能都引出来先。顺便喷一下boot上的那个小按键：太小太不方便按了，于是在上面的boot脚上焊了个大点的四脚按键，按起来有感觉多了~</p><p><img src="../../../../medias/boardPic/2021/tools/Ch573Base.jpg" alt="CH573F底板"></p><p>CH573虽支持2线调试，可惜不支持JLink，自然也不支持JLink全家桶，官方提供的下载器以及ISP工具虽然能用，但是不好用，于是先从打造好用的下载工具开始~</p><p>感谢沁恒的FAE提供了ISP下载的参考例程，基于提供的lib文件，用QT做了个简洁的下载工具，简洁而不简单~</p><p><img src="../../../../medias/boardPic/2021/tools/MyWCHISP.png" alt="MyWCHISP"></p><p>主要实现如下功能：</p><ol><li>选择待烧写的BIN文件。（如何生成BIN文件请参考上一篇）</li><li>检测CH573F是否进入USB ISP模式，进入则连接。</li><li>连接成功后则自动烧写（可勾选选择是否自动烧写）</li><li>烧写成功后自动复位运行app。</li></ol><p>CH573F自带的bootloader只支持冷启动，即上电时检测到boot脚被按下后会运行boot，如果通过RST脚复位后也不识别，所以如果要每次要操作的时候就得不断上下电还要按住boot键。好在发现了这篇文档：</p><p>从应用跳到芯片Boot的方法：<a href="https://www.cnblogs.com/iot-fan/p/14344779.html" target="_blank" rel="noopener">https://www.cnblogs.com/iot-fan/p/14344779.html</a></p><p>于是将其copy进工程，通过解析串口指令“enisp”自动进入bootloader并执行烧写，烧写成功后又自动运行。终于可以摆脱硬件在不断电的情况下自动完成了。</p><p>需要该软件的小伙伴可联系我获取~</p>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BLE </tag>
            
            <tag> RISC-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CH573F调试笔记 一 之初尝</title>
      <link href="/2021/07/21/CH573F01Start/"/>
      <url>/2021/07/21/CH573F01Start/</url>
      
        <content type="html"><![CDATA[<p>最近需要一款低成本的蓝牙芯片，KT6368A是不错的选择，但需外配MCU，需要一款能像NRF52840那样带USB的蓝牙SOC，价格又要美美的，于是就找到了它：<strong>CH573F</strong> ！官方资源开放的连PCB的源文件都提供了，刚好某创和某配都提供了免费PCB打样，赶紧去薅了一把羊毛，PCB文件直接拿去打样，在此非常感谢沁恒市场经理李先生，不仅提供了CH573F和CH569的样片，还提供了一个烧写器用于调试，真是太贴心了~</p><p><img src="../../../../medias/boardPic/2021/tools/CH573Board.jpg" alt="CH573F BLEBoard Pic"></p><h3 id="CH573F"><a href="#CH573F" class="headerlink" title="CH573F"></a>CH573F</h3><ul><li>32位RISC处理器WCH RISC-V3A</li><li>支持RV32 IMAC指令集，支持<strong>单周期乘法和硬件除法</strong></li><li>内置<strong>18K SRAM，512K Flash</strong> ROM，支持ICP、ISP和IAP，支持OTA无线升级</li><li>集成2.4GHz RF收发器和基带及链路控制，提高优化的协议栈和应用层API，支持组网</li><li>内置USB控制器和USB收发器，支持USB2.0全速和低速主机或设备</li><li>多种低功耗模式：Idle，Halt, Sleep, Shutdown, 内置电池电压低压监控，最低睡眠电流0.3uA</li><li>内置AES-128加解密单元，芯片唯一ID</li><li>其他传统接口：UARTx4、SPI、12位ADC、8通道触摸按键等。</li></ul><p>主频不详？！貌似只有20MHz？32MHz的主晶振时钟输入，不明白为何主频这么低。先不管了，谁让它这么便宜呢~ （ 看程序主频应该最高<strong>60MHz</strong>）顺便上一张沁恒的BLE选型：<br><img src="../../../../medias/boardPic/2021/tools/CHBLE.png" alt="CH BLE 选型"></p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol><li>先从官网下载所需资源：<a href="http://www.wch.cn/products/CH573.html" target="_blank" rel="noopener">http://www.wch.cn/products/CH573.html</a><br>Datasheet：CH573DS1.PDF<br>CH573评估板说明及参考应用例程：CH573EVT.ZIP<br>集成开发环境(IDE)：MounRiver Studio(MRS)<br>CH573F板载天线核心板：CH573PCB.ZIP<br>系统平台低功耗蓝牙开发接口库：WCHBleLib_MultiOS.ZIP<br>沁恒芯云物联平台说明及参考应用例程：WCHIOT.ZIP<br>单片机系列芯片程序烧录软件：WCHISPTool_Setup.exe</li><li>开发环境只能用官方提供的MounRiver Studio，看介绍也支持JLink，慢慢熟悉之。</li></ol><h3 id="埋坑笔记-HW"><a href="#埋坑笔记-HW" class="headerlink" title="埋坑笔记 - HW"></a>埋坑笔记 - HW</h3><ol><li>芯片背面的焊盘要接地！芯片背面的焊盘要接地！芯片背面的焊盘要接地！整个芯片的地只有芯片背面的焊盘，所以必须要可靠接地！对于DIY者来说不够友好，焊之前处理下也能搞定。</li><li>电感L1是22uH电感，0805封装的，这个封装以及32K RTC晶振的封装、0603封装的LED、0402的某几个电容都很蛋疼，翻箱倒柜找好物料然后开焊。</li><li>芯片的仿真引脚：PB14-TIO-SWDIO，PB15-TCK-SWCLK，默认boot PIN：PB22</li><li>两线仿真调试接口通过ISP工具配置，仿真调试接口启用后，PB15和PB14仅用作TCK和TIO，不再用于GPIO或外设复用功能引脚。如需复用，需关闭仿真调试接口功能。<br><img src="../../../../medias/boardPic/2021/tools/CHusrCfg.png" alt="用户配置信息"></li><li>系统SysTick定时器：64位，递减型计数器，支持HCLK或HCLK/8作为时基，具有较高优先级。</li><li>上电后默认不启用DC-DC，而是提供直通电源，为了降低正常运行时的系统功耗，可以选择<strong>启用DC-DC提升电源能耗利用率</strong>，工作电流通常会下降到直通方式的<strong>60%</strong>左右。</li><li>USB Device模式下，有0、1、2、3、4、共5组双向端点，最大数据包长64字节。<ul><li>断点0是默认断点，发送和接收共用64字节数据缓冲区。</li><li>端点1、2、3各自包含一个发送端点IN和一个接收端点OUT，发送和接收各有一个独立的64字节或者<strong>双64字节</strong>数据缓冲区，支持批量、中断和实时/同步传输。</li><li>端点4包括一个发送端点IN和一个接收端点OUT，发送和接收各有一个独立的64字节数据缓冲区，支持批量、中断和实时/同步传输。</li></ul></li><li>USB总线上的上拉电阻可以由软件随时设置是否启用。当R8_USB_CTRL中的RB_UC_DEV_PU_EN置1时，在内部位USB总线的DP/DM引脚连接上拉电阻，并启用USB设备功能。</li></ol><h3 id="埋坑笔记-SW"><a href="#埋坑笔记-SW" class="headerlink" title="埋坑笔记 - SW"></a>埋坑笔记 - SW</h3><p>硬件手册基本上粗略看完一遍，接下来开始折腾软件。</p><ol><li>首先安装WCHISPTool_Setup.exe，按住Boot按键上电，如下图示，确认能识别出CH573F的设备，选择开启仿真。<br><img src="../../../../medias/boardPic/2021/tools/WCHISP.png" alt="CH573F ISP"></li><li>安装MounRiver Studio，解压CH573EVT.ZIP，然后导入一个USB的例程 ..\USB\Device\CompoundDev\CompoundDev.wvproj，貌似是一个USB HID的复合设备，导入成功后CTRL+B编译，只要没有其他误操作，这个过程基本上都会编译成功的，在obj目录下会有编译出的CompoundDev.hex文件，重复上一步的操作，按住Boot进USB ISP模式，通过WCHISPTool将该文件下载进去，重启后查看设备管理器，人体学输入设备中会多出两个USB输入设备。</li><li>测试蓝牙工程，BLE目录下有25个例程，真丰富，选择其中HID KeyBoard测试，导入..\BLE\HID_Keyboard\HID_Keyboard.wvproj，编译之。重复ISP的步骤，将生成的HID_Keyboard.hex文件烧入其中，打开手机蓝牙搜寻设备，会出现HID Keybrod的蓝牙设备，连接后提示配置实体键盘。打开手机App便签，然后就会每隔一秒钟收到一个字符，从abcdef ~ xyz。</li><li>BLE目录下的文档 <strong>沁恒低功耗蓝牙软件开发参考手册.pdf</strong> ，搞蓝牙的话还是需要好好看看的。</li><li>配置MounRiver Studio，生成BIN文件：（Help文件中有描述）<ul><li>右键工程配置选项 - &gt; C/C++ Build - &gt; Settings , 切换至 Build Steps标签页，在下面的 Post-build steps中输入如下命令：</li><li>“${eclipse_home}\toolchain\RISC-V Embedded GCC\bin\riscv-none-embed-objcopy”  -O binary “${ProjName}.elf”  “..\${ProjName}.bin”</li><li>或者直接在GNU RISC-V Cross Greate Flash Image选项中，选择Output file format <strong>Raw binary</strong>即可。<br>不知为何，我这边使用MounRiver Studio，Ctrl+B编译 很慢很慢的，make -j4或-j8都一样的慢。</li></ul></li><li>博客园中有非常好的笔记，满满的干货，在此记录并感谢之~<br><a href="https://www.cnblogs.com/iot-fan/tag/CH57x/" target="_blank" rel="noopener">https://www.cnblogs.com/iot-fan/tag/CH57x/</a><br>TMOS系统介绍：<a href="https://www.cnblogs.com/iot-fan/p/13460082.html" target="_blank" rel="noopener">https://www.cnblogs.com/iot-fan/p/13460082.html</a><br>用户Boot和App：<a href="https://www.cnblogs.com/iot-fan/p/14976335.html" target="_blank" rel="noopener">https://www.cnblogs.com/iot-fan/p/14976335.html</a><br>从应用跳到芯片Boot的方法：<a href="https://www.cnblogs.com/iot-fan/p/14344779.html" target="_blank" rel="noopener">https://www.cnblogs.com/iot-fan/p/14344779.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BLE </tag>
            
            <tag> RISC-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不正经的PCB板</title>
      <link href="/2021/05/21/PCBCard/"/>
      <url>/2021/05/21/PCBCard/</url>
      
        <content type="html"><![CDATA[<p>自从JLC将PCB打样费降至5元/款，JP跟进免费打样，可乐坏我和我的小伙伴了，每个月不打上几款感觉亏了几个亿。而同时又带来了新的苦恼：<strong>免费打样券用不完肿么办？</strong>于是PCB打板开始不正经起来~ </p><ol><li><p>给我的Mini FlasherPortable加个盖板<br><img src="../../../../medias/boardPic/2021/pcb/FlasherPortable.jpg" alt="MyMiniFlasherPortabale"></p></li><li><p>给我的电源做个盖板及支架<br>淘宝淘了个电源模块，5V-30V输入，0.5V-30V输出，可显示输出电流、功率等，很不错的宝贝。<br><img src="../../../../medias/boardPic/2021/pcb/Power.jpg" alt="MyPower"><br><img src="../../../../medias/boardPic/2021/pcb/Power2.jpg" alt="MyPowerCe"></p></li><li><p>PCB可以做结构支撑<br><img src="../../../../medias/boardPic/2021/pcb/jiegou.jpg" alt="MyGUIBoard"></p></li><li><p>PCB可以做日历显示（还没来得及焊接，芯片涨价涨的玩不起了…）<br><img src="../../../../medias/boardPic/2021/pcb/rili.jpg" alt="MyGUIBoard"></p></li><li><p>PCB板可以做名片：（擦掉部分信息）<br><img src="../../../../medias/boardPic/2021/pcb/mingpian.jpg" alt="MyMingPian"></p></li><li><p>PCB可以做霸气的挪车牌：（刺客五六七的飞镖）<br><img src="../../../../medias/boardPic/2021/pcb/feibiao.jpg" alt="FeiBiaoNuoChe"></p></li><li><p>PCB可以做太极图<br><img src="../../../../medias/boardPic/2021/pcb/taiji.jpg" alt="TaiJi"></p></li><li><p>PCB可以做杯垫<br><img src="../../../../medias/boardPic/2021/pcb/beidian.jpg" alt="BeiDian"></p></li><li><p>做个卡片<br><img src="../../../../medias/boardPic/2021/pcb/Ka1.jpg" alt="KaPian+"><br><img src="../../../../medias/boardPic/2021/pcb/Ka2.jpg" alt="KaPian-"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> PCB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KT6368A - 8脚的蓝牙BLE</title>
      <link href="/2021/04/13/KT6368A/"/>
      <url>/2021/04/13/KT6368A/</url>
      
        <content type="html"><![CDATA[<p>偶然间见到了这款神芯：KT6368A，8脚的蓝牙UART透传芯片，淘宝零售价1.6元/pcs，禁不住赶紧做板一试。<br><img src="../../../../medias/boardPic/2021/tools/KT6368A.jpg" alt="KT6368A BLE Pic"></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>KT6368A芯片是一款支持蓝牙双模的纯数据芯片，蓝牙5.1版本。芯片的亮点在超小尺寸，超级价格。以及简单明了的透传和串口AT控制功能。大大降低了嵌入蓝牙在其它产品的开发难度和成本。<br>同时支持<strong>SPP</strong>和<strong>BLE</strong> 。但是只能任选其中一个协议使用。<br>备注：这款芯片最大的特点，就是成本低，使用简单，生产简单。无他。</p><p>电流：芯片上电启动是20mA，马上进入低功耗广播20uA和唤醒4mA交替。连接成功就一直都是4mA。<br>电路：简洁的令人发指！如果能把晶振内置，再多引出2个IO那简直太完美了！<br>串口：波特率默认115200.<br>PIN2：连接状态指示。连接成功后输出高电平，未连接为高阻态。 – <strong>这脚如果能配置成发送完成状态指示就好了，不然咋知道发送是否完成？</strong></p><h3 id="AT指令"><a href="#AT指令" class="headerlink" title="AT指令"></a>AT指令</h3><ol><li><p>指令格式：AT+CMD[parama]\r\n<br>&lt;IND&gt; : 数据反馈是蓝牙把各种状态和数据信息反馈给主机，以<strong>&lt;IND&gt;</strong>作为开头<br>CMD指令：</p><table><thead><tr><th align="center">CMD</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">AT+CT</td><td align="center">设置波特率，如AT+CT01\r\n</td></tr><tr><td align="center">AT+CZ</td><td align="center">芯片复位</td></tr><tr><td align="center">AT+CW</td><td align="center">芯片恢复出厂设置</td></tr><tr><td align="center">AT+CL</td><td align="center">芯片低功耗设置</td></tr><tr><td align="center">AT+BM</td><td align="center">设置BLE蓝牙名称，如AT+BMMyBle\r\n</td></tr><tr><td align="center">AT+BN</td><td align="center">设置BLE的MAC地址</td></tr><tr><td align="center">AT+BD</td><td align="center">设置SPP蓝牙名称</td></tr><tr><td align="center">AT+BS</td><td align="center">设置BLE连接密码，此功能没有实现</td></tr><tr><td align="center">–</td><td align="center">–</td></tr><tr><td align="center">AT+QT</td><td align="center">查询系统的波特率</td></tr><tr><td align="center">AT+QL</td><td align="center">查询系统的低功耗状态</td></tr><tr><td align="center">AT+TM</td><td align="center">查询BLE蓝牙名称</td></tr><tr><td align="center">AT+TN</td><td align="center">查询BLE蓝牙地址</td></tr><tr><td align="center">AT+TN</td><td align="center">查询SPP蓝牙名称</td></tr><tr><td align="center">AT+TS</td><td align="center">查询BLE蓝牙连接密码,功能保留</td></tr><tr><td align="center">–</td><td align="center">–</td></tr><tr><td align="center">AT+B401\r\n</td><td align="center">开启BLE功能，AT+B400\r\n关闭该功能</td></tr><tr><td align="center">AT+B501\r\n</td><td align="center">开启SPP功能，AT+B500\r\n关闭该功能</td></tr><tr><td align="center">AT+T4\r\n</td><td align="center">查询BLE功能是否打开，芯片返回T4+01或T4+00</td></tr><tr><td align="center">AT+T5\r\n</td><td align="center">查询SPP功能是否打开，芯片返回T5+01或T5+00</td></tr></tbody></table></li><li><p>设置波特率：AT+CT01\r\n=9600;     05=115200;    07=512000;    10=1000000;     还支持其他的一些波特率设置，请参考手册。</p></li><li><p>关闭BLE或SPP功能后，必须重新上电，此功能才能生效。</p></li><li><p>芯片返回错误信息表：</p><table><thead><tr><th align="center">错误信息</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">ER+1\r\n</td><td align="center">接收的数据帧不对</td></tr><tr><td align="center">ER+2\r\n</td><td align="center">接收的命令不存在，如发送的AT+KK字符串不正确</td></tr><tr><td align="center">ER+3\r\n</td><td align="center">接收的AT指令，没有收到回车换行，\r\n</td></tr><tr><td align="center">ER+4\r\n</td><td align="center">发送的指令给的参数超范围了</td></tr><tr><td align="center">ER+(5,6,8)\r\n</td><td align="center">保留</td></tr><tr><td align="center">ER+7\r\n</td><td align="center">在BLE连接成功状态下，发送数据给手机，手机端未打开notify</td></tr></tbody></table></li></ol><h3 id="BLE透传"><a href="#BLE透传" class="headerlink" title="BLE透传"></a>BLE透传</h3><ol><li>目前支持BLE纯数传，BLE和SPP均只能作为从，也就是“SERVER”端。</li><li><strong>一旦蓝牙被连接之后，芯片自动进入透传模式。不再识别AT指令</strong>。</li><li>单次吞吐的数据最大是<strong>1024</strong>字节，支持16位或128位的UUID。128位的需要特别定制。</li><li>BLE的UUID说明：<br>4.1    ：    主UUID是“<strong>FFF0</strong>”<br>4.2    ：    特征1的UUID是“<strong>FFF1</strong>”，特征是“<strong>WRITE</strong>” “<strong>NOTIFY</strong>”<br>4.3    ：    特征2的UUID是“<strong>FFF2</strong>”，特征是“<strong>WRITE</strong>” “<strong>NOTIFY</strong>”<br>4.4    ：    特征3的UUID是“<strong>FFF3</strong>”，特征是“<strong>WRITE</strong>” </li></ol><h3 id="SPP透传"><a href="#SPP透传" class="headerlink" title="SPP透传"></a>SPP透传</h3><ol><li>SPP走的是经典蓝牙2.1的协议，不推荐使用，新产品建议使用BLE。</li><li>单次吞吐的数据最大是<strong>1024</strong>字节。</li><li>SPP是经典蓝牙里面的一个子链路。</li><li>SPP数传和BLE是互斥的，如果用SPP请关闭BLE。</li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li>发送AT+TM\r\n，查询当前BLE名称。</li><li>发送AT+BMMyBle\r\n，设置BLE名称为MyBle，收到OK响应。</li><li>发送AT+CZ\r\n，让芯片复位并重启，然后继续查询蓝牙名称，看是否是MyBle。</li><li>发送AT+T4\r\n和AT+T5\r\n，查询BLE和SPP的打开情况，结果都是打开的状态。</li><li>发送AT+B500\r\n关闭SPP功能，只保留BLE功能。</li><li>打开手机蓝牙，扫描设备，居然查找到的蓝牙为MyBle\r\n，说明执行AT+BM时出错，重新发送<strong>AT+BMMyBle</strong>，返回OK。</li><li>手机安装LightBlue Explorer APK进行测试。找到MyBle连接之，可以看到信号强度。<br><img src="../../../../medias/boardPic/2021/tools/phone.png" alt="LightBlue Explorer Pic"></li><li>串口调试记录：收发都比较简单，手机端是二进制显示，所有要发送1234需要发送0x31323334才行。<br><img src="../../../../medias/boardPic/2021/tools/serialDebug.png" alt="串口调试Pic"></li></ol><p>操作很简单，没有任何流控，发送后也不清楚发送成功了没，什么时候可以再发送也不清楚，自个写程序管理吧。有此神芯，仍无法如虎添翼啊…<br><img src="../../../../medias/boardPic/2021/tools/tiger.jpg" alt="TIGER Pic"></p>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BLE </tag>
            
            <tag> KT6368A </tag>
            
            <tag> 蓝牙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GD32E505 SPI Flash</title>
      <link href="/2021/04/12/GD32E50x05SpiFlash/"/>
      <url>/2021/04/12/GD32E50x05SpiFlash/</url>
      
        <content type="html"><![CDATA[<p>GD32E50x有专用的SQPI外设，支持接SQPI接口的PSRAM、Flash等，不过LQFP64封装的不支持，这些管脚都分配到了PF口或PG口上。好在SPI0且仅有SPI0支持4线模式，可以尝试四线接口的SPI Flash。</p><h3 id="GD32E505-SPI0四线操作模式："><a href="#GD32E505-SPI0四线操作模式：" class="headerlink" title="GD32E505 SPI0四线操作模式："></a>GD32E505 SPI0四线操作模式：</h3><p>SPI四线模式用于控制四线SPI flash外设。要配置成SPI四线模式，首先要确认<strong>TBE</strong>位置1，且<strong>TRANS</strong>位清零，然后将SPI_QCTL寄存器中的<strong>QMOD</strong>位置1。在SPI 四线模式，SPI_CTL0寄存器中BDEN位、BDOEN位、CRCEN位、CRCNT位、FF16位、RO位和LF位保持清零，且MSTMOD位置1，以保证SPI工作于主机模式。SPIEN位、PSC位、CKPL位和CKPH位根据需要进行配置。 </p><p>SPI四线模式有两种运行模式：<strong>四线写模式</strong>和<strong>四线读模式</strong>，通过SPI_QCTL寄存器中的QRD位进行配置。 </p><h3 id="四线写模式"><a href="#四线写模式" class="headerlink" title="四线写模式"></a>四线写模式</h3><p>当SPI_QCTL寄存器中的QMOD位置1且QRD位清零时，SPI工作在四路写模式。在四路写模式中，MOSI、MISO、IO2 和IO3 都用作输出引脚。在SCK产生时钟信号后，一旦数据写入SPI_DATA寄存器（TBE位清零）且SPIEN位置1时，SPI将会通过这四个引脚发送写入的数据。一旦SPI开始数据传输，它总是在数据帧结束时检查TBE标志位的状态，若不能满足条件则停止传输。 </p><p>四路模式下发送操作流程： </p><ol><li>根据应用需求，配置SPI_CTL0和SPI_CTL1中的时钟预分频、时钟极性、相位等参数； </li><li>将SPI_QCTL中的QMOD位置1，然后将SPI_CTL0中的SPIEN位置1来使能SPI功能； </li><li>向SPI_DATA寄存器中写入一个字节的数据，TBE标志位将会清零； </li><li>等待硬件将TBE位重新置位，然后写入下一个字节数据。<br><img src="../../../../medias/boardPic/2021/tools/QSPIWrite.png" alt="四线SPI写时序 Pic"></li></ol><h3 id="四线写模式-1"><a href="#四线写模式-1" class="headerlink" title="四线写模式"></a>四线写模式</h3><p>当SPI_QCTL寄存器中的QMOD位和QRD位都置1时，SPI工作在四路读模式。在四路读模式中，MOSI、MISO、IO2 和IO3都用作输入引脚。当数据写入SPI_DATA寄存器（此时TBE位被清零）且SPIEN位置1时，SPI开始在SCK信号线上产生时钟信号。写数据到SPI_DATA寄存器只是为了产生SCK时钟信号，所以可以写入任何数据。SPI开始数据传输之后，每发送一个数据帧都要检测SPIEN位和TBE位，若条件不满足则停止传输。所以软件需要一直向SPI_DATA写空闲数据，以产生SCK时钟信号。 </p><p>四路模式下接收操作流程： </p><ol><li>根据应用需求，配置SPI_CTL0和SPI_CTL1中时钟预分频、时钟极性、相位等参数； </li><li>将SPI_QCTL中的QMOD位和QRD位置1，然后将SPI_CTL0中的SPIEN位置1来使能SPI功能； </li><li>写任意数据（例如0xFF）到SPI_DATA寄存器； </li><li>等待RBNE位置1，然后读SPI_DATA寄存器来获取接收的数据； </li><li>写任意数据（例如0xFF）到SPI_DATA寄存器，以接收下一个字节数据。<br><img src="../../../../medias/boardPic/2021/tools/QSPIRead.png" alt="四线SPI读时序 Pic"></li></ol><h3 id="SPI停止流程"><a href="#SPI停止流程" class="headerlink" title="SPI停止流程"></a>SPI停止流程</h3><p>不同运行模式下采用不同的流程来停止SPI功能。<br><strong>SPI四路模式</strong> ：在禁用SPI四路模式或者关闭SPI功能之前，软件应该先检查：TBE位置1，TRANS位清零，SPI_QCTL中的QMOD位和SPI_CTL0中的SPIEN位清零。 </p><h3 id="例程分析"><a href="#例程分析" class="headerlink" title="例程分析"></a>例程分析</h3><p>木有例程。。。只能自个啃啃试试了，如果不行，就换成2线的跟普通SPI Flash操作流程一样就完事了。</p>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GD32E505 </tag>
            
            <tag> CortexM33 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GD32E505 Flash 操作</title>
      <link href="/2021/04/12/GD32E50x04Flash/"/>
      <url>/2021/04/12/GD32E50x04Flash/</url>
      
        <content type="html"><![CDATA[<h3 id="GD32E505-Flash："><a href="#GD32E505-Flash：" class="headerlink" title="GD32E505 Flash："></a>GD32E505 Flash：</h3><ol><li><p>设备唯一ID（UNIQUE ID ,96bit，只能按字32位访问），基地址：0x1FFF_F7E8</p></li><li><p>闪存的前512K字节空间内，CPU执行指令需要0~4个等待时间。</p></li><li><p>闪存页大小为<strong>8KB</strong>，支持32位字/16位半字编程，页擦除和整片擦除。</p></li><li><p>2K字节 OTP块（一次性编程），用于存储用户数据。</p></li><li><p>16字节的选项字节，根据用户需求配置，当系统复位时，选项字节被加载到选项字节控制寄存器。</p></li><li><p>GD32E505_CL闪存基地址和构成：</p><table><thead><tr><th align="center">闪存</th><th align="center">名称</th><th align="center">地址范围</th><th align="center">大小</th></tr></thead><tbody><tr><td align="center">主闪存</td><td align="center">Page0</td><td align="center">0x0800_0000~0x0800_1FFF</td><td align="center">8KB</td></tr><tr><td align="center">主闪存</td><td align="center">Page1</td><td align="center">0x0800_2000~0x0800_3FFF</td><td align="center">8KB</td></tr><tr><td align="center">主闪存</td><td align="center">…..</td><td align="center">…..</td><td align="center">8KB</td></tr><tr><td align="center">主闪存</td><td align="center">Page63</td><td align="center">0x0807_E000~0x0807_FFFF</td><td align="center">8KB</td></tr><tr><td align="center">信息块 CL</td><td align="center">引导Bootloader</td><td align="center">0x1FFF_B000~0x1FFF_F7FF</td><td align="center">18KB</td></tr><tr><td align="center">选项字节</td><td align="center">选项字节</td><td align="center">0x1FFF_F800~0x1FFF_F80F</td><td align="center">16B</td></tr><tr><td align="center">一次性编程</td><td align="center">OTP</td><td align="center">0x1FFF_7000~0x1FFF_77FF</td><td align="center">2KB</td></tr></tbody></table></li><li><p>选项字节说明 : 每次系统复位后，选项字节被重载到FMC_OBSTAT和FMC_WP寄存器后，选项字节生效。选项字节的补字节具体为选项字节取反。当选项字被重载时，如果选项字节的补字节和选项字节补匹配，FMC_OBSTAT的OBERR位将被置1，选项字节被强制设置为0xFF。若选项字节和其补字节同为0xFF，则OBERR位补置位。</p><table><thead><tr><th align="center">地址</th><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">0x1FFF_F800</td><td align="center">SPC</td><td align="center">选项字节安全保护值，0xA5未保护，除0xA5和0xCC外的任何值：保护级别低，0xCC：保护级别高</td></tr><tr><td align="center">0x1FFF_F801</td><td align="center">SPC_N</td><td align="center">SPC补字节</td></tr><tr><td align="center">0x1FFF_F802</td><td align="center">USER</td><td align="center">[7:6] : BOR_TH ，BOR复位阈值<br>[5:3] : 保留<br>[2] : nRST_STDBY，0：设置待机模式时产生复位而不是进入待机模式。1：设置待机模式时进入待机模式而不产生复位。<br>[1] : nRST_DPSLP，0：设置深度睡眠模式时产生复位而不进入深度睡眠模式。1：设置深度睡眠模式时进入深度睡眠模式而不产生复位。<br>[0] : nWDG_HW， 0：硬件是能独立看门狗功能。1：软件使能独立看门狗功能。</td></tr><tr><td align="center">0x1FFF_F803</td><td align="center">USER_N</td><td align="center">SPC补字节</td></tr><tr><td align="center">0x1FFF_F804</td><td align="center">DATA[7:0]</td><td align="center">用户定义数据7到0位</td></tr><tr><td align="center">0x1FFF_F805</td><td align="center">DATA_N[7:0]</td><td align="center">DATA补字节的7到0位</td></tr><tr><td align="center">0x1FFF_F806</td><td align="center">DATA[15:8]</td><td align="center">用户定义数据15到8位</td></tr><tr><td align="center">0x1FFF_F807</td><td align="center">DATA_N[15:8]</td><td align="center">DATA补字节的15到8位</td></tr><tr><td align="center">0x1FFF_F808</td><td align="center">WP[7:0]</td><td align="center">页擦除/编程保护值的7到0位 <br>[0] : 保护生效<br>[1] : 未保护</td></tr><tr><td align="center">0x1FFF_F809</td><td align="center">WP_N[7:0]</td><td align="center">WP补字节的7到0位</td></tr><tr><td align="center">0x1FFF_F80A</td><td align="center">WP[15:8]</td><td align="center">页擦除/编程保护值的15到8位</td></tr><tr><td align="center">0x1FFF_F80B</td><td align="center">WP_N[15:8]</td><td align="center">WP补字节的15到8位</td></tr><tr><td align="center">0x1FFF_F80C</td><td align="center">WP[23:16]</td><td align="center">页擦除/编程保护值的23到16位</td></tr><tr><td align="center">0x1FFF_F80D</td><td align="center">WP_N[23:16]</td><td align="center">WP补字节的23到16位</td></tr><tr><td align="center">0x1FFF_F80E</td><td align="center">WP[31:24]</td><td align="center">页擦除/编程保护值的31到24位</td></tr><tr><td align="center">0x1FFF_F80F</td><td align="center">WP_N[31:24]</td><td align="center">WP补字节的31到24位</td></tr></tbody></table></li><li><p>安全防护：<br><strong>未保护状态</strong>：当将SPC字节和它的补字节设置为0x5AA5，系统复位后闪存将处于非安全保护状态，主存储器和选项字节可以被所有操作模式访问。<br><strong>保护等级低</strong>：当设置SPC字节为任何除0xA5或0xCC外的值，系统复位以后，低安全保护状态生效。需要注意的是，若修改过程中，MCU的调试模块依然和外部JTAG/SWD设备相连，需要用上电复位代替系统复位以使得修改后的保护状态生效。在低安全保护状态下，<strong>主存储闪存块仅能被用户代码访问且前8KB的闪存自动处于页擦除/编程保护状态下</strong>。在调试模式下，或从SRAM中启动时，以及从boot loader区启动时，这些模式下对主存储块的操作都被禁止。如果在这些模式下读主存储块，将产生总线错误。如果在这些模式下，对主存储块进行编程或擦除操作，FMC_STAT寄存器的WPERR位将被置1。但这些模式下都可以对选项字节进行操作，从而可以通过该方式失能安全保护功能。如果将SPC字节和它的补字节设置为0x5AA5，安全保护功能将失效，并自动触发一次整片擦除操作。<br><strong>保护等级高</strong>：当设置SPC字节为0xCC，激活高安全保护等级。当编程选择该保护等级时，调试模式，从SRAM中启动，或者从boot loader启动都被禁止。主存储闪存块可由用户代码的所有操作进行访问。SPC字节禁止再次编程。所以，如果高保护等级被激活，将不能再降回到低保护等级或无保护等级。 </p><p><strong><font color=#FF3300>空芯片默认该值为0xFF？所以无法烧写程序？？蛋疼的设计！！</font></strong></p></li></ol><h3 id="例程分析"><a href="#例程分析" class="headerlink" title="例程分析"></a>例程分析</h3><p>Examples/FMC中有三个例程；</p><ol><li>Erase_Program: 提供了fmc_erase_pages和fmc_program的操作例程。</li><li>Security_protection: 设置Security和解unSecurity。</li><li>Write_Protection: 设置写保护，参考意义不大。</li></ol><p>基于以上这三个例程，基本上对flash的操作就不是事了。</p>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GD32E505 </tag>
            
            <tag> CortexM33 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GD32E505 USART and DMA</title>
      <link href="/2021/03/23/GD32E50x03DMA/"/>
      <url>/2021/03/23/GD32E50x03DMA/</url>
      
        <content type="html"><![CDATA[<h3 id="GD32E505-DMA："><a href="#GD32E505-DMA：" class="headerlink" title="GD32E505 DMA："></a>GD32E505 DMA：</h3><ol><li>DMA控制器有12个通道，DMA0有7个通道，DMA1有5个通道。</li><li>DMA控制器和Cortex-M33内核共享系统总线。传输长度可配置，最大65536.</li><li>AHB、APB外设、片上闪存和SRAM都可以作为访问的源端和目的端。<br><img src="../../../../medias/boardPic/2021/pcan/DMA0.png" alt="GD32E505 DMA0请求"><br><img src="../../../../medias/boardPic/2021/pcan/DMA1.jpg" alt="GD32E505 DMA1请求"></li><li>支持软件优先级（低、中、高、极高）和硬件优先级（通道号越低，优先级越高）。</li><li>将DMA_CHxCTL寄存器的CHEN位清零，可以停止DMA传输。</li><li>若清零CHEN位时，DMA传输已经完成，之后未对任意寄存器进行操作前便是能DMA通道，则不会触发任何DMA传输。</li></ol><h3 id="GD32E505-USART："><a href="#GD32E505-USART：" class="headerlink" title="GD32E505 USART："></a>GD32E505 USART：</h3><ol><li>所有USART都支持DMA功能，以实现高速率的数据通信。</li><li>IDLE帧检测（IDLEF）;</li><li>USART0/1/2支持全功能，USART3/4有下面功能未实现：<br><strong>智能卡模式<br>同步模式<br>硬件流操作（CTS/RTS）<br>设置数据极性</strong></li><li>USART5跟其他的不一样！！</li></ol><h3 id="例程分析"><a href="#例程分析" class="headerlink" title="例程分析"></a>例程分析</h3><ol><li>Examples\USART 有不少UART的例程，参考DMA的来copy一份改改就可以用了。</li><li>注意：USART5跟其他的不一样！！包括查询状态都不一样！</li><li>填坑：进入空闲中断后的处理也不一样！</li><li>注意USART管脚重映射的配置。RM - P187页</li><li>我用了USART2和USART5做RS485，根据DMA的通道号修改配置DMA模式+IDLE中断，收发都OK了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GD32E505 </tag>
            
            <tag> CortexM33 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GD32E505 USB分析</title>
      <link href="/2021/03/22/GD32E50x02USB/"/>
      <url>/2021/03/22/GD32E50x02USB/</url>
      
        <content type="html"><![CDATA[<h3 id="GD32E505-USBHS模块特性："><a href="#GD32E505-USBHS模块特性：" class="headerlink" title="GD32E505 USBHS模块特性："></a>GD32E505 USBHS模块特性：</h3><ol><li>包含一个4KB的FIFO RAM</li><li>主机模式下，支持12个通道，包含2个发送FIFO（周期性发送FIFO和非周期性发送FIFO）和1个接收FIFO（由所有通道共享）。</li><li>在设备模式下，支持6个OUT端点和6个IN端点。 – 有点少…</li><li>在设备模式下，包含6个发送FIFO（每个IN端点一个发送FIFO）和1个接收FIFO（由所有的OUT端点共享）</li><li>在设备模式下，USBHS在初始化后保持掉电状态，利用VBUS引脚上的5V电源连接USB主机后或者置位<strong>USBHS_GCCFG寄存器中VDEN</strong>控制位，USBHS将进入供电状态。USBHS首先打开DP信号线上的上拉电阻，之后主机会检测到一个连接事件。</li><li>USBHS支持软件断开，通过置位USBHS_DCTL寄存器中SD控制位进行强制断开，SD控制位置位后，如果当前设备为高速，USBHS会首先返回到全速设备，然后关闭DP信号线上的上拉电阻，如果是全速，USBHS会直接关闭上拉电阻，这样USB主机会在USB总线上检测到设备断开。</li></ol><h3 id="例程分析"><a href="#例程分析" class="headerlink" title="例程分析"></a>例程分析</h3><ol><li>usb_rcu_config() : 配置USB的时钟，目测只支持配置system_clock为48M、72M、120M和168M，所以默认程序配置的为168M，没有配置为180M。</li><li>usb_timer_init() : 配置了TIMER2作为USB的延时定时器，usb_mdelay和usb_udelay都是调用了hw_delay来实现的，其他在使用定时器时需要避免使用TIMER2.</li><li>程序中会判断是否需要检测VBUS，配置VBUS_SENSING_ENABLED，在usb_conf.h中屏蔽使能。</li><li>USB设备描述符居然藏在GD32E50x_usbhs_library\device\class\cdc\Source\cdc_acm_core.c，鄙视之！为毛不单独整个文件啊！如果需要修改VID和PID，是在cdc_dev_desc中。</li><li>基本上不需要做什么修改，USB CDC的例程很容易就跑起来了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GD32E505 </tag>
            
            <tag> CortexM33 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GD32E505 Start - 环境搭建</title>
      <link href="/2021/03/21/GD32E50x01Start/"/>
      <url>/2021/03/21/GD32E50x01Start/</url>
      
        <content type="html"><![CDATA[<p>摘掉了CANFD的GD32E505犹如折翼了的天使~光环不再，奈何PCB已做回，好在GD的FAE给力，在芯片价格满天飞的今天提供了10片样片，感动的泪牛满面！纵有千般不爽还是立马搞起！<br><img src="../../../../medias/boardPic/2021/pcan/GD32E505Pic.jpg" alt="GD32E505 Board Pic"></p><h3 id="GD32E505"><a href="#GD32E505" class="headerlink" title="GD32E505"></a>GD32E505</h3><ul><li>180MHz, Arm Cortex-M33 内核，ARMv8架构。</li><li>SRAM/Flash：80/128，96/256，128/512 KB</li><li>高速USB，内置PHY，480Mbit/s。</li><li>两个12bit SAR ADC，2.5MSPS，两个DAC，9个16bit 定时器，一个32bit通用定时器。</li><li>QSPI Flash。</li><li>USART: 高达<strong>22.5MBits/s</strong> ， 支持IrDA SIR编解码，支持LIN，支持ISO7816-3.</li><li>96bits Unique ID，位于0x1FFF_F7E8</li></ul><p>虽然没了CANFD，但还是亮点满满，尤其是内置高速USB PHY，相比STM32来说诚意满满！STM32貌似只有STM32F7有几款型号内置了高速PHY，蛋疼。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ol><li>先从GD32官网下载所需资源<br>英文：<a href="http://www.gd32mcu.com/en/download/" target="_blank" rel="noopener">http://www.gd32mcu.com/en/download/</a><br>中文：<a href="http://gd32mcu.com/cn/download" target="_blank" rel="noopener">http://gd32mcu.com/cn/download</a><br>选择GD32E5，主要下载以下几个文件：<br>GD32E505xx_Datasheet_Rev1.2.pdf - 数据手册<br>GD32E50x_RM_Rev1.2.pdf - 寄存器手册<br>GD32E50x_AddOn_V1.2.0.zip - 安装后MDK能识别出GD32E5的芯片<br>GD32E50x_Firmware_Library_V1.1.2.rar - 固件库<br>GD32E50x_Firmware_Library_User_Guide_Rev1.1.rar - 库函数手册<br>GD32E50x_Demo_Suites_V1.1.1.rar - Demo板参考例程，Demo板的原理图也藏在这里面<br>GD32DfuDrivers_V3.6.6.6167.rar - GD32 DFU驱动<br>GD32All_In_OneProgrammer_V1.2.8.9234.rar - 下载程序<br>GD32_Dfu_Tool_V3.8.2.9056.rar - DFU上位机程序<br>GD32_ISP_CLI(Windows)1.0.0.5109.rar - ISP程序<br>GD_Link_Programmer_V4.3.7.9954.rar - GDLink的上位机下载程序</li><li>MDK - 我最开始用的MDK5.23版本，各种问题，后来果断升级至最新版 5.34版本<br>GD32的例程使用的是AC6的编译器。</li><li>JLink驱动：JLink_Windows_V696.exe ，这个版本的支持GD32E505器件，老版本的不支持。</li></ol><h3 id="USB-CDC例程"><a href="#USB-CDC例程" class="headerlink" title="USB CDC例程"></a>USB CDC例程</h3><ol><li>解压GD32E50x_Firmware_Library_V1.1.2.rar</li><li>打开Examples\USBHS\usb_device\cdc_acm\MDK-ARM工程，编译。</li><li>选择JLink，连接方式选择SWD，JTAG/SWD都支持，下载即可。</li></ol><h3 id="埋坑笔记"><a href="#埋坑笔记" class="headerlink" title="埋坑笔记"></a>埋坑笔记</h3><ol><li>例程很多，对每一个外设基本上都有相应的例程，蛋疼的是大部分都没工程，只有几个.c文件。在USBHS中有MDK和IAR的工程，所以直接以此工程入手。</li><li>在MDK5.23版本中，遇到自带的AC6编译时有很多问题，于是从其他高版本的MDK中拷贝出相应的AC6编译链，替换Keil\ARM\ARMCLANG，编译没问题了，在下载选项中没法选择JLink，后来查找到MDK中的描述：<a href="https://www.keil.com/support/docs/4053.htm" target="_blank" rel="noopener">https://www.keil.com/support/docs/4053.htm</a><blockquote><p><strong>µVISION DEBUGGER: J-LINK/J-TRACE Debug Support for ARMv8m Architecture</strong><br>To resolve this issue, open the Keil\Tools.ini file with a text editor and in the section starting with ARMADS search for the debug drivers for Arm v8m architecture and add TDRV4 to the list of supported drivers in CPUDLL3 line.<br>Tools.ini:<br>[ARMADS]<br>CPUDLL0=SARM.DLL(TDRV17,TDRV18,TDRV19)                              # Drivers for ARM7/9 devices<br>CPUDLL1=SARMCM3.DLL(TDRV0,TDRV1,TDRV2,TDRV3,TDRV4,TDRV5,TDRV6,…   # Drivers for Cortex-M devices<br>CPUDLL2=SARMCR4.DLL(TDRV4)                                          # Drivers for Cortex-R4 devices<br>CPUDLL3=SARMV8M.DLL(TDRV2,<strong>TDRV4</strong>,TDRV13,TDRV14,TDRV15,TDRV16)        # Drivers for <strong>ARMv8-M</strong> devices<br>…<br>TDRV3=BIN\CMSIS_AGDI.dll(“CMSIS-DAP Debugger”)<br>TDRV4=<strong>Segger\JL2CM3.dll(“J-LINK / J-TRACE Cortex”)</strong><br>TDRV5=BIN\DbgFM.DLL(“Models Cortex-M Debugger”)<br>…</p></blockquote></li><li>JLink不支持GD32E5的芯片，升级JLink驱动至V696版本即可。Segger的WIKI上还给GD32E507开了个专页，<a href="https://wiki.segger.com/GigaDevice_GD32E5" target="_blank" rel="noopener">https://wiki.segger.com/GigaDevice_GD32E5</a><br>如果使用SEGGER的开发环境，可以下载GigaDevice_GD32E507Z_TestProject_ES_V452b.zip试试。</li><li>我这边还遇到过无法下载的情况，换了电脑换了MDK534还是不行，后来用ISP工具，通过串口给下载了个程序后就OK了，顺便提一下，USB DFU也不行！</li><li>程序下载后无限重启，约1S重启了，各种查找才发现原来是看门狗莫宁奇妙的被开启了，真是日了狗！RM上写的默认是关闭的，但是可以通过配置选项字打开，我也不清楚是个例，还是就这么设计的，程序主循环里不断喂狗就行了。</li><li>能下载能运行了，其他都不是事了，回头慢慢研究吧。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GD32E505 </tag>
            
            <tag> CortexM33 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PEAK PCAN</title>
      <link href="/2021/03/21/MyPCAN/"/>
      <url>/2021/03/21/MyPCAN/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>Github上又发现了宝，不废话先上网址：<br><strong>PCAN USB</strong> 固件 (支持成品 CANtack、CANable 硬件修改 或者 STMF042系列芯片)：<br><a href="https://github.com/moonglow/pcan_cantact" target="_blank" rel="noopener">https://github.com/moonglow/pcan_cantact</a><br><strong>PCAN USB PRO</strong>  固件(支持STM32F405\407芯片)：<br><a href="https://github.com/moonglow/pcan_pro_x" target="_blank" rel="noopener">https://github.com/moonglow/pcan_pro_x</a></p><h3 id="pcan-cantact-F072版本"><a href="#pcan-cantact-F072版本" class="headerlink" title="pcan_cantact - F072版本"></a>pcan_cantact - F072版本</h3><p>马上拉下代码，一看蒙圈了，没有keil工程，只有Makefile，大体上看了下用的是arm-none-eabi-gcc编译链，我这编译A8的编译链应该不行，懒的配环境了直接动手移植，找个072的工程把其中的源码都删了，然后把pcan_cantact中的代码都先添加进去，然后一编译果然一堆错误，然后就开始对着error一个一个的解决，一番操作猛如虎，一看error 250！应该是startup_stm23f072.s文件的问题，换回之前keil工程里的.s文件，稍作修改就OK了，翻出我的F072的带CAN的小板子down进去一试，居然识别出来了！虽然没有驱动但是很开心，至少说明usb枚举成功了，然后找驱动，官网下载<strong>PeakOemDrv.exe</strong>安装后，就识别出来了！先上板图留念：<br><img src="../../../../medias/boardPic/2021/pcan/PCAN.jpg" alt="PCAN USB - F072"><br><img src="../../../../medias/boardPic/2021/pcan/PCANView.png" alt="PCANView成功识别"><br>再翻出之前买的笨重的USB2CAN工具，连接后配置相同的波特率，收发都正常！代码没做啥修改，只是改了改LED就跑起来了，开心ing…</p><h3 id="PCAN-USB-PRO-F407版本"><a href="#PCAN-USB-PRO-F407版本" class="headerlink" title="PCAN USB PRO - F407版本"></a>PCAN USB PRO - F407版本</h3><p>打铁需趁热，翻出407的板子同样的套路移植好代码，usb上电down程序，又是一番操作猛如虎，NaNi？USB豪无反应！左一想应该时钟不正确，改时钟配置重新下进去还是没反应！好吧，看程序里默认的配置用的应该是8M晶振，算了不改时钟了–换晶振！额…还是不行，看了看USB初始化部分代码居然用的是USBHS！难道需要外扩外扩USB3300来跑高速？不怕，哥有的是板子！翻出之前带USB3300的407板子，继续一番猛如虎的操作，还是毫无反应啊！右一想可能是USB的管脚配置不正确，毕竟ULPI要配置好多个腿，巴拉了巴拉发现USB管脚居然用的是PB14、PB15！奇怪，难道407的高速USB内置了PHY？之前的USB FS都是用的PA11、PA12，不管了，找了个能引出PB14、PB15管脚的407板子，然后把它飞到USB座上，USB线一插听到了熟悉的叮咚声音，虎躯一震，赶紧打开设备管理器一看PCAN USB PRO设备直接识别出来了！呼，长呼一口气！<br>后来看了下人家的README.md文件，上面清晰的注明：</p><p>Target hardware:</p><ul><li>Any STM32F407/405 based boards with 8MHz oscillator<br>Pinout:<table><thead><tr><th>PIN/PINS</th><th>DESCRIPTION</th></tr></thead><tbody><tr><td>PC10</td><td>STATUS LED</td></tr><tr><td>PA2/PA3</td><td>TX/RX CAN1 LED</td></tr><tr><td>PC6/PC7</td><td>TX/RX CAN2 LED</td></tr><tr><td>PB8/PB9</td><td>CAN1 RX/TX</td></tr><tr><td>PB5/PB6</td><td>CAN2 RX/TX</td></tr><tr><td>PB14/PB15</td><td>USB DM/DP</td></tr></tbody></table></li></ul><ul><li>Be sure to use <strong>PB14/PB15</strong> pins for USB</li><li>PRO FD firmware has better performance on windows ( due internal PEAK driver implementation )</li></ul><p>都怪自己太心急绕了些弯路，不过虎躯又一震，还支持CANFD哪！虽然407不支持，但是协议有了，改了改配了配，嗯，果然识别成PCAN-USB Pro FD了，还多了个PCAN-USB-Pro FD LIN！爽歪歪，虽然不知道LIN有啥用。<br>这里的修改主要是在工程配置选项中增加如下配置：PCAN_PRO_FD=1,INCLUDE_LIN_INTERFACE=1,USB_WITHOUT_ISR=0<br>开始改版，用407就不要浪费了，两路CAN、两路LIN、两路RS485，六个LED，SPI Flash，按键，然后今天的主角闪亮登场：<br><img src="../../../../medias/boardPic/2021/pcan/PCANProFD.jpg" alt="MyPCANPro"><br>程序里修改了下LED管脚配置，然后down进去就识别出来了，还是用笨重的USB2CAN工具调试，两路CAN收发都正常！PCAN View可以选择配置CANFD的Norminal Bit Rate和Data Bit Rate，Data Bit Rate只有2MBits/s和6MBits/s两种，不知道是不是固件的原因。<br><img src="../../../../medias/boardPic/2021/pcan/PCANViewCANFD.png" alt="MyPCANPro FD PcanView"><br>还有附送的PLIN，虽然暂时用不到，谁知道以后会不会用上呢~<br><img src="../../../../medias/boardPic/2021/pcan/PLINView.png" alt="PLIN View"></p><h3 id="高速USB-CANFD"><a href="#高速USB-CANFD" class="headerlink" title="高速USB + CANFD"></a>高速USB + CANFD</h3><p>至此虽然已经实现了PCAN，但是没有高速USB没有CANFD，心里总有些遗憾，然后东逛西逛在立创商城上下到了GD32E505的datasheet，虎躯震了又震！这货不就是我一直在找寻的嘛！内置高速USB PHY，至此3路CANFD！选择GD32E505RB/C/E，LQFP64 pin就可以实现了，关于CANFD的描述如下：<br><img src="../../../../medias/boardPic/2021/pcan/E505CANDesc.png" alt="E505 CAN的描述"><br>三路CAN，支持CAN FD，速率也能到6MBit/S！还等什么哪，407的板子还没捂热乎就在它的基础上改出了一个同时支持高速USB、两路CAN FD、QSPI Flash的高级版，立马下单投板。焦急的等板子的过程中找资料找例程，第一次接触GD的片子，可得仔细点~<br>事实再一次狠狠的打了我的脸，快就慢！我以为我捡到了宝结果是一坨屎！CANFD在新版本的datasheet上连个鬼影都木的！别说CANFD了，连CAN都没了！带着一丝丝希望咨询GD的工程师得到如下的回复：<br><strong>“ 505把CAN去掉了，508才有，508还没出样片！”</strong><br>真是句句扎心啊…太坑了…<br>可怜我那可爱的GD32E505xUSBHSxCANFD的小裸板了~<br><img src="../../../../medias/boardPic/2021/pcan/GD32E505Board.jpg" alt="E505Board"></p>]]></content>
      
      
      <categories>
          
          <category> TOOL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> PCAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的 J-Link 们</title>
      <link href="/2021/03/05/iToos-JLinks/"/>
      <url>/2021/03/05/iToos-JLinks/</url>
      
        <content type="html"><![CDATA[<p>喝水不忘挖井人，感谢Segger提供这么好的工具，感谢XHWW、T大神等的帮助，也感谢凤舞天大哥的支持，这些年学习了很多，也一直都在享受便利的开发，非常非常的感谢~</p><p>同时声明：本人不卖盗版，请支持正版，支持正版，支持正版！</p><h3 id="JLink-Flasher-Portable-Plus"><a href="#JLink-Flasher-Portable-Plus" class="headerlink" title="JLink - Flasher Portable Plus"></a>JLink - Flasher Portable Plus</h3><p>自从Segger的Flasher Portable诞生以来，垂涎滴了又滴，官方介绍如 <a href="https://www.segger.com/products/production/flasher/models/flasher-portable-plus/" target="_blank" rel="noopener">链接</a> ，简单来说就是带1.8寸屏显的离线烧录器，支持N多ARM和非ARM核的芯片，支持JTAG/SWD/FINE/SPD等 <a href="https://www.segger.com/products/debug-probes/j-link/technology/interface-description/" target="_blank" rel="noopener">接口</a>，还自带680mAh的可充电锂电池，超级方便，虽然自个也曾做过离线烧写，基于DAPLink来搞的，但是在量产使用时心里总不放心，最近花了些时间研究下了Flasher Portable，一不小心给搞出来了，非常开心~ 如下图：<br><img src="../../../../medias/boardPic/2021/tools/FlasherPortablePlus.jpg" alt="FlasherPortablePlus Pic"><br>MDK下测试JTAG下载速度可到21000KHZ，SWD却只有12000KHZ，我用足矣。按惯例，去掉接口缓冲芯片（芯片太小，手焊太麻烦，而且我老眼昏花，小芯片上的丝印经常看不清，一不小心就方向焊反了，查找起来太麻烦）、电源输入输出那套啰里啰唆部分电路，然后精简如下：<br><img src="../../../../medias/boardPic/2021/tools/MiniFlashPortable.jpg" alt="Mini FlasherPortablePlus Pic"><br>测试速度不影响，灰常好用，还给赛到了个小盒子里，方便携带~</p><h3 id="JLink-Flasher-Pro-V4"><a href="#JLink-Flasher-Pro-V4" class="headerlink" title="JLink - Flasher Pro V4"></a>JLink - Flasher Pro V4</h3><p>年代比较久远了，出自于XHWW大神之作，后来偶得一正版Flasher Pro，就读出了固件，顺便精简了一下穿上了外衣，非常非常的好用，陪伴我很多年，如下图示：<br><img src="../../../../medias/boardPic/2021/tools/FlasherPro.jpg" alt="Flasher Pro Pic"><br>可惜Flasher系列都不支持虚拟串口，好在有RTT，自从有了RTT，虚拟串口是路人~<br>当然也少不了我的Mini Flasher Pro V4：<br><img src="../../../../medias/boardPic/2021/tools/miniFlasher.jpg" alt="Mini Flasher Pro Pic"></p><h3 id="JLink-Ultra-amp-JLink-Pro-V4"><a href="#JLink-Ultra-amp-JLink-Pro-V4" class="headerlink" title="JLink Ultra &amp; JLink Pro V4"></a>JLink Ultra &amp; JLink Pro V4</h3><p>也是出自于XHWW大神之作，重新修改了下原理及PCB，两层板画下来了，stm32f4+Cyclone4，高速USB、以太网，速度最高能到50000KHz，下载速度很快，但也没那么快，受限于目标芯片的flash速度，下载也就那样，不过配套的JScope可是飞一般的快。第一版的JPro是17年搞的：<br><img src="../../../../medias/boardPic/2021/tools/JUV4.jpg" alt="JLink Ultra &amp; JLink Pro V4 Pic"><br>这个只是偶尔的拿出来用用，大部分时间都在吃灰，但却是一块很不错的arm+fpga的开发板，有需要的时候还可以拿出来鼓捣鼓捣。后来又做了下修改：<br><img src="../../../../medias/boardPic/2021/tools/JProV4.jpg" alt="JLink Ultra &amp; JLink Pro V4 New Pic"></p><h3 id="JLink-V10-amp-JLink-V11"><a href="#JLink-V10-amp-JLink-V11" class="headerlink" title="JLink V10 &amp; JLink V11"></a>JLink V10 &amp; JLink V11</h3><p>依然是出自于XHWW大神之作，JLink V10、V11、Flasher Portable都使用了RSA2048签名，公钥存储在固件中用以验证签名是否正确，不正确不运行，私钥是没办法弄出来的，所以想要破解还是有一定难度的，感兴趣的可以私聊，我也是在XHWW大神的指点下孤岛了好久才不小心给试了出来。<br><img src="../../../../medias/boardPic/2021/tools/V10.jpg" alt="JLink V10 &amp; JLink V11 Pic"><br>顺便提一下，V11的固件是可以在V10上直接运行的，下载速度也没啥变化，不晓得官方做了哪些改动，并且LPC4337也有DAPLink的固件，速度也是非常非常的快。可以按住按键更新不同的程序。<br>同样也少不了Mini V10 &amp; Mini V11，虽然只支持3.3V电平，但是下载速度不受影响：<br><img src="../../../../medias/boardPic/2021/tools/miniV10.jpg" alt="Mini V10 Pic"><br><img src="../../../../medias/boardPic/2021/tools/MiniV11.jpg" alt="Mini V11 Pic"></p><h3 id="JLink-V9"><a href="#JLink-V9" class="headerlink" title="JLink V9"></a>JLink V9</h3><p>V9的年代更是很老了，貌似官方都停止更新了吧？曾经很好用很好用，没啥校验，固件烧上就可以跑，目前dll貌似对序列号后四字节校验做了判断。自从有了V10和mini flasher，就很少用V9了，留照纪念之。<br><img src="../../../../medias/boardPic/2021/tools/V9.jpg" alt="最初的JLink V9 Pic"><br>后来各种改，穿衣服，还和usb hub放一起，再加上个CH34x的一个usb转串口芯片，把Jlink、USB转RS232、USB转RS485、Hub接口都放一起了，也很好用的~<br><img src="../../../../medias/boardPic/2021/tools/iToolsV9.jpg" alt="iToolsV9 Pic"><br>顺便提一下，序列号后四字节的校验如果不正确，Jlinkarm.dll有时会弹出defective的错误框，要么处理下jlinkarm.dll，要么就把这个序列号校验给加上，如果需要可以联系我，可提供针对序列号的校验码。（JLinkarm.dll中有此函数，可惜没有export出来，不过可以找出此函数然后调用它来计算）</p><h3 id="JLink-OB们"><a href="#JLink-OB们" class="headerlink" title="JLink OB们"></a>JLink OB们</h3><p>最初的JLink OB是103，在没有V9之前一直都是OB103陪伴着我，后来有了OB 072，还有了OB K22，貌似OB K22和JLink Mini硬件一致的，而且可用的版本众多，官方貌似开源了原理图了，所以照着画个板写个boot跳到App就可以运行了，其中最牛的是下面这个了：支持4路SWD、3路UART，是在Nodic的NRF91DK开发板上的，原理图都是公开的，照着画个就完事了。在使用一个JLink同时调多个目标板的时候，灰常灰常的好用，按下按键就切过去了~<br><img src="../../../../medias/boardPic/2021/tools/OB072andV9.jpg" alt="JLink OB072 Pic"><br><img src="../../../../medias/boardPic/2021/tools/OBK22.jpg" alt="JLink OBK22 Pic"><br><img src="../../../../medias/boardPic/2021/tools/OBK22s4.jpg" alt="JLink OBK22s4 Pic"></p><h3 id="其他小工具"><a href="#其他小工具" class="headerlink" title="其他小工具"></a>其他小工具</h3><p>JLink SWD ISO: 隔离小板，只隔离SWD，速度不快，调试电机时还是很有必要。<br><img src="../../../../medias/boardPic/2021/tools/JSWDISO.jpg" alt="JLink SWD ISO Pic"><br>Xilinx的JTAG HS3、SMT2，很快，很好用，还有一路虚拟串口，支持选择1.8V/3.3V电平。<br><img src="../../../../medias/boardPic/2021/tools/JTAGH3.jpg" alt="Xilinx FPGA debug tool"></p><h3 id="JLink-CMDs"><a href="#JLink-CMDs" class="headerlink" title="JLink CMDs"></a>JLink CMDs</h3><ol><li>exec InvalidateFW</li><li>exec GetSNChecksum</li><li>exec GetUID</li><li>exec GetSignature</li><li>exec VerifySignature</li><li>exec SetSN</li><li>exec ClearFeatures</li></ol>]]></content>
      
      
      <categories>
          
          <category> TOOL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> JLink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CH569 第一篇：GPIO</title>
      <link href="/2020/10/16/CH569_02_GPIO/"/>
      <url>/2020/10/16/CH569_02_GPIO/</url>
      
        <content type="html"><![CDATA[<h3 id="第一篇：GPIO"><a href="#第一篇：GPIO" class="headerlink" title="第一篇：GPIO"></a>第一篇：GPIO</h3><p>额… 从还没入门到放弃~</p>]]></content>
      
      
      <categories>
          
          <category> RiscV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CH569 </tag>
            
            <tag> Risc-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CH569 开篇</title>
      <link href="/2020/10/16/CH569_01_Infor/"/>
      <url>/2020/10/16/CH569_01_Infor/</url>
      
        <content type="html"><![CDATA[<p>终于等到了你：CH569！早早的看到过CH569的介绍，觉得强悍的一批，特别适合搭配一个小FPGA干事，而且价格还不贵，又是国产芯，准备一步一步开始进坑了，先copy一份官网的介绍。</p><h3 id="CH569概述："><a href="#CH569概述：" class="headerlink" title="CH569概述："></a>CH569概述：</h3><p>CH569/565 微控制器使用 RISC-V3A 内核， 支持 RISC-V 指令的 IMAC 子集。 片上集成超高速USB3.0主机和设备控制器（内置 PHY）、千兆以太网控制器、专用高速 SerDes 控制器（内置 PHY，可直接驱动光纤）、高速并行接口HSPI、数字视频接口（DVP）、 SD/EMMC 接口控制器、加解密模块 ， 片上 128 位宽 DMA设计可保障大数据量的高速传输， 可广泛应用于流媒体、即时存储、超高速USB3.0 FIFO、通讯延长、安防监控等应用场景。</p><p><img src="http://www.wch.cn/uploads/image/20200721/Sl2mLGuKpXycnwjU9IlD1ydCxfdKedAORUW3l4BS.png" alt="img"></p><p>功能</p><ul><li>RISC-V内核，120MHz系统主频，支持单周期乘法和硬件除法、可编程中断控制器、低功耗两级流水线</li><li>448KB CodeFlash，32KB DataFlash，16KB的32位宽SRAM，32/64/96KB可配置的128位宽SRAM</li><li>内置超高速USB3.0控制及收发器（内置PHY），支持USB3.0 主机Host/设备Device模式、OTG功能，支持USB3.0 HUB</li><li>内置高速USB2.0控制及收发器（内置PHY），支持USB2.0 主机Host/设备Device模式，支持控制/批量/中断/同步传输</li><li>内置千兆以太网控制器（Ethernet），提供RGMII和RMII PHY接口，支持10/100/1000Mbps的传输速率</li><li>内置数字视频接口DVP，可配置8/10/12位数据宽度，支持YUV、RGB、JPEG压缩数据</li><li>内置高速并行接口HSPI，可配置8/16/32位数据宽度，内置FIFO，支持DMA，最快传输速度约为3.8Gbps</li><li>内置SerDes控制及收发器（内置PHY，可直接驱动光纤），支持网线（仅使用1组差分线）传输90米，支持1.25Gbps高速差分信号通讯</li><li>内置EMMC控制器，支持单线、4线、8线数据通讯模式，符合EMMC卡4.4和4.5.1规范，兼容5.0规范</li><li>支持AES/SM4算法，8种组合加解密模式，支持SRAM/EMMC/HSPI外设接口数据加解密</li><li>4组UART，最高波特率6Mbps，兼容16C550，内置FIFO，多个触发级</li><li>2组SPI接口，支持主从(Master/Slave)模式，内置FIFO，支持DMA</li><li>主动并口：8位数据，15位地址总线</li><li>3组26位定时器，支持定时、计数、信号捕捉、PWM调制输出，4组扩展PWM输出，占空比可调</li><li>49个通用IO，8个可设置电平/边沿中断，部分引脚具有复用及映射功能</li><li>内置看门狗，集成2线调试接口，支持在线仿真</li><li>支持低功耗模式，支持部分GPIO、USB、以太网信号唤醒</li><li>芯片ID号：唯一64bit ID识别号</li><li>封装：QFN68,QFN40</li></ul>]]></content>
      
      
      <categories>
          
          <category> RiscV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CH569 </tag>
            
            <tag> Risc-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT SQLite 笔记</title>
      <link href="/2020/04/21/QTSqlNote/"/>
      <url>/2020/04/21/QTSqlNote/</url>
      
        <content type="html"><![CDATA[<h3 id="记录QT-SQLite3"><a href="#记录QT-SQLite3" class="headerlink" title="记录QT SQLite3"></a>记录QT SQLite3</h3><p>如下讨论关于Qt进行SQLite的基本操作。<br>转自：<a href="https://www.cnblogs.com/lvdongjie/p/7068530.html" target="_blank" rel="noopener">https://www.cnblogs.com/lvdongjie/p/7068530.html</a></p><h3 id="添加数据库驱动、设置数据库名称、数据库登录用户名、密码"><a href="#添加数据库驱动、设置数据库名称、数据库登录用户名、密码" class="headerlink" title="添加数据库驱动、设置数据库名称、数据库登录用户名、密码"></a>添加数据库驱动、设置数据库名称、数据库登录用户名、密码</h3><pre class=" language-cpp"><code class="language-cpp">QSqlDatabase database <span class="token operator">=</span> QSqlDatabase<span class="token operator">::</span><span class="token function">addDatabase</span><span class="token punctuation">(</span><span class="token string">"QSQLITE"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> database<span class="token punctuation">.</span><span class="token function">setDatabaseName</span><span class="token punctuation">(</span><span class="token string">"database.db"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>database<span class="token punctuation">.</span><span class="token function">setUserName</span><span class="token punctuation">(</span><span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  database<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>database<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> database<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">qFatal</span><span class="token punctuation">(</span><span class="token string">"failed to connect."</span><span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//QSqlQuery类提供执行和操作的SQL语句的方法。</span>    <span class="token comment" spellcheck="true">//可以用来执行DML（数据操作语言）语句，如SELECT、INSERT、UPDATE、DELETE， </span>    <span class="token comment" spellcheck="true">//以及DDL（数据定义语言）语句，例如CREATE TABLE。</span>    <span class="token comment" spellcheck="true">//也可以用来执行那些不是标准的SQL的数据库特定的命令。</span>    QSqlQuery sql_query<span class="token punctuation">;</span>     QString create_sql <span class="token operator">=</span> <span class="token string">"create table student (id int primary key, name varchar(30), age int)"</span><span class="token punctuation">;</span>    QString select_max_sql <span class="token operator">=</span> <span class="token string">"select max(id) from student"</span><span class="token punctuation">;</span>    QString insert_sql <span class="token operator">=</span> <span class="token string">"insert into student values (?, ?, ?)"</span><span class="token punctuation">;</span>    QString update_sql <span class="token operator">=</span> <span class="token string">"update student set name = :name where id = :id"</span><span class="token punctuation">;</span>    QString select_sql <span class="token operator">=</span> <span class="token string">"select id, name from student"</span><span class="token punctuation">;</span>    QString select_all_sql <span class="token operator">=</span> <span class="token string">"select * from student"</span><span class="token punctuation">;</span>    QString delete_sql <span class="token operator">=</span> <span class="token string">"delete from student where id = ?"</span><span class="token punctuation">;</span>    QString clear_sql <span class="token operator">=</span> <span class="token string">"delete from student"</span><span class="token punctuation">;</span>    sql_query<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span>create_sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sql_query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> sql_query<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"table created!"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="查询最大id"><a href="#查询最大id" class="headerlink" title="查询最大id"></a>查询最大id</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> max_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>sql_query<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span>select_max_sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sql_query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> sql_query<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>sql_query<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        max_id <span class="token operator">=</span> sql_query<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token function">QString</span><span class="token punctuation">(</span><span class="token string">"max id:%1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>max_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><pre class=" language-cpp"><code class="language-cpp">sql_query<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span>insert_sql<span class="token punctuation">)</span><span class="token punctuation">;</span>sql_query<span class="token punctuation">.</span><span class="token function">addBindValue</span><span class="token punctuation">(</span>max_id<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sql_query<span class="token punctuation">.</span><span class="token function">addBindValue</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sql_query<span class="token punctuation">.</span><span class="token function">addBindValue</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sql_query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> sql_query<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token string">"inserted!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><pre class=" language-cpp"><code class="language-cpp">sql_query<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span>update_sql<span class="token punctuation">)</span><span class="token punctuation">;</span>sql_query<span class="token punctuation">.</span><span class="token function">bindValue</span><span class="token punctuation">(</span><span class="token string">":name"</span><span class="token punctuation">,</span> <span class="token string">"Qt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sql_query<span class="token punctuation">.</span><span class="token function">bindValue</span><span class="token punctuation">(</span><span class="token string">":id"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sql_query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> sql_query<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token string">"updated!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="查询部分数据"><a href="#查询部分数据" class="headerlink" title="查询部分数据"></a>查询部分数据</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sql_query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>select_sql<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> sql_query<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>sql_query<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> id <span class="token operator">=</span> sql_query<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        QString name <span class="token operator">=</span> sql_query<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token function">QString</span><span class="token punctuation">(</span><span class="token string">"id:%1    name:%2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="查询所有数据"><a href="#查询所有数据" class="headerlink" title="查询所有数据"></a>查询所有数据</h3><pre class=" language-cpp"><code class="language-cpp">sql_query<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span>select_all_sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sql_query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> sql_query<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>sql_query<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> id <span class="token operator">=</span> sql_query<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        QString name <span class="token operator">=</span> sql_query<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> age <span class="token operator">=</span> sql_query<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token function">QString</span><span class="token punctuation">(</span><span class="token string">"id:%1    name:%2    age:%3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">arg</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><pre class=" language-cpp"><code class="language-cpp">sql_query<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span>delete_sql<span class="token punctuation">)</span><span class="token punctuation">;</span>sql_query<span class="token punctuation">.</span><span class="token function">addBindValue</span><span class="token punctuation">(</span>max_id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sql_query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> sql_query<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token string">"deleted!"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h3><pre class=" language-cpp"><code class="language-cpp">sql_query<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span>clear_sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>sql_query<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> sql_query<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> <span class="token string">"cleared"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="关闭数据库"><a href="#关闭数据库" class="headerlink" title="关闭数据库"></a>关闭数据库</h3><pre class=" language-cpp"><code class="language-cpp">database<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><pre class=" language-cpp"><code class="language-cpp">QFile<span class="token operator">::</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"database.db"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="带有加密功能的-SQLite-Qt-插件（v0-5）"><a href="#带有加密功能的-SQLite-Qt-插件（v0-5）" class="headerlink" title="带有加密功能的 SQLite Qt 插件（v0.5）"></a>带有加密功能的 SQLite Qt 插件（v0.5）</h3><p>以下转自：<a href="https://www.devbean.net/2016/05/qt-sqlite-plugin-with-encryption-v05/" target="_blank" rel="noopener">https://www.devbean.net/2016/05/qt-sqlite-plugin-with-encryption-v05/</a><br>QtCipherSqlitePlugin 是一个能够加密 SQLite 数据的 Qt 插件，经过之前几个版本的更新，现在已经有不少使用。</p><p>经过这一次的调整，编译插件变得非常简单：只需要使用 QtCreator 打开插件中 sqlitecipher 文件夹下的 sqlitecipher.pro 进行编译即可。编译后，需要将生成的 sqlitecipher.dll 复制到 Qt 的 plugins/sqldrivers 文件夹下。本次更新。豆子使用 Qt 5.5 和 Qt 5.7 进行了测试，如果有其它版本的 Qt 不能正常使用，请及时联系豆子。</p><p>当然，本次更新我们还是使用了 SQLITECIPHER 作为插件的名字。如果需要修改这个名字，Qt4 需要修改 smain.cpp 中的 DriverName 定义，Qt5 需要修改 SqliteCipherDriverPlugin.json 中的 SQLITECIPHER 一行。</p><p>出去上述调整，更为重要的是，本次更新增加了很多新功能，包括为原来没有密码的 SQLite 数据库添加密码，修改数据库密码以及删除密码。下面我们将着重介绍这些功能的使用。</p><h3 id="检查-QtCipherSqlitePlugin-是否成功加载"><a href="#检查-QtCipherSqlitePlugin-是否成功加载" class="headerlink" title="检查 QtCipherSqlitePlugin 是否成功加载"></a>检查 QtCipherSqlitePlugin 是否成功加载</h3><p>我们可以使用下面的代码检查 QtCipherSqlitePlugin 是否成功加载：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> QSqlDatabase<span class="token operator">::</span><span class="token function">drivers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果输出中有 SQLITECIPHER 的名字，那么恭喜你，插件没有问题！</p><h3 id="为没有加密的数据库增加密码"><a href="#为没有加密的数据库增加密码" class="headerlink" title="为没有加密的数据库增加密码"></a>为没有加密的数据库增加密码</h3><p>Qt 默认提供的 SQLite 插件是没有加密功能的。新版本的 QtCipherSqlitePlugin 支持为原本没有加密的数据库增加密码，使用方法如下：</p><pre class=" language-cpp"><code class="language-cpp">QSqlDatabase dbconn <span class="token operator">=</span> QSqlDatabase<span class="token operator">::</span><span class="token function">addDatabase</span><span class="token punctuation">(</span><span class="token string">"SQLITECIPHER"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setDatabaseName</span><span class="token punctuation">(</span><span class="token string">"test.db"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setConnectOptions</span><span class="token punctuation">(</span><span class="token string">"QSQLITE_CREATE_KEY"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dbconn<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Can not open connection: "</span> <span class="token operator">&lt;&lt;</span>         dbconn<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">driverText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span>CONNECTION_FAILED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面的代码，我们使用 test.db 数据库，将密码设置为 test，同时指定连接选项为QSQLITE_CREATE_KEY。此时，调用open()函数之后，QtCipherSqlitePlugin 将使用改密码为这个数据库进行加密。</p><h3 id="删除数据库密码"><a href="#删除数据库密码" class="headerlink" title="删除数据库密码"></a>删除数据库密码</h3><p>QtCipherSqlitePlugin 可以删除数据库密码，此时需要提供原密码，并使用连接选项QSQLITE_REMOVE_KEY，如下：</p><pre class=" language-cpp"><code class="language-cpp">QSqlDatabase dbconn <span class="token operator">=</span> QSqlDatabase<span class="token operator">::</span><span class="token function">addDatabase</span><span class="token punctuation">(</span><span class="token string">"SQLITECIPHER"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setDatabaseName</span><span class="token punctuation">(</span><span class="token string">"test.db"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setConnectOptions</span><span class="token punctuation">(</span><span class="token string">"QSQLITE_REMOVE_KEY"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dbconn<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Can not open connection: "</span> <span class="token operator">&lt;&lt;</span> dbconn<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">driverText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span>CONNECTION_FAILED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="更新数据库密码"><a href="#更新数据库密码" class="headerlink" title="更新数据库密码"></a>更新数据库密码</h3><p>QtCipherSqlitePlugin 可以更新数据库原有密码，需要设置原密码，并且使用连接选项QSQLITE_UPDATE_KEY设置新密码，具体代码如下：</p><pre class=" language-cpp"><code class="language-cpp">QSqlDatabase dbconn <span class="token operator">=</span> QSqlDatabase<span class="token operator">::</span><span class="token function">addDatabase</span><span class="token punctuation">(</span><span class="token string">"SQLITECIPHER"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setDatabaseName</span><span class="token punctuation">(</span><span class="token string">"test.db"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>dbconn<span class="token punctuation">.</span><span class="token function">setConnectOptions</span><span class="token punctuation">(</span><span class="token string">"QSQLITE_UPDATE_KEY=newtest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dbconn<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"Can not open connection: "</span> <span class="token operator">&lt;&lt;</span> dbconn<span class="token punctuation">.</span><span class="token function">lastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">driverText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span>CONNECTION_FAILED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果原密码不正确，QtCipherSqlitePlugin 会直接返回错误。<br>如果新密码设置为空，例如QSQLITE_UPDATE_KEY=，则作用等同于删除密码。<br>如果需要，可以到 github 上面获取 git 库，checkout 代码的 0.5 标签即可。</p><p>GITHUB：<a href="https://github.com/devbean/QtCipherSqlitePlugin" target="_blank" rel="noopener">https://github.com/devbean/QtCipherSqlitePlugin</a></p><h3 id="SQLite的管理"><a href="#SQLite的管理" class="headerlink" title="SQLite的管理"></a>SQLite的管理</h3><p>管理工具挺多的，这里简单介绍几款：<br><strong>SQLite Manager</strong>：开放源代码的SQLite管理工具，用来管理本地电脑上的SQLite数据库，可以独立运行（以XULRunner方式），也可以作为Firefox、Thunderbird、Seamonkey、Songbird、Komodo、Gecko等的插件。<br><strong>SQLite Administrator</strong>：一个用来管理SQLite数据库文件的图形化工具，可进行创建、设计和管理操作。提供代码编辑器具有自动完成和语法着色，支持中文，适合初学者。<br><strong>SQLite Database browser</strong>：一个SQLite数据库的轻量级GUI客户端，基于Qt库开发，界面清洁，操作简单，主要是为非技术用户创建、修改和编辑SQLite数据库的工具，使用向导方式实现。</p>]]></content>
      
      
      <categories>
          
          <category> QT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QT </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NUC505 - HS USB</title>
      <link href="/2020/02/21/NUC505/"/>
      <url>/2020/02/21/NUC505/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>本来做的是M484，看好了它的片上高速USB、双SDHC、QSPI FLash等，结果入了新塘第一坑：LQFP64封装是.4间距的，偶直接拖了个STM32F205的封装过来，.5间距的，结果就是下面这样：<br><img src="../../../../medias/boardPic/2020/M484.jpg" alt="M484 -&gt; NUC505"></p><p>无意间于Whycan论坛（原填坑网）上发现了这款神U：NUC505：</p><ul><li>高速USB Device，USB2.0 USBHost. SD Host.</li><li>128 KSRAM，512KB/2MB SPI Flash（片上无flash）</li><li>含有浮点运算单元和DSP的ARM® Cortex®-M4内核，最高可运行至100MHz</li><li>内建双声道24位音频解码器（某些型号）</li><li>封装友好：LQFP48、QFN48、LQFP64、QFN88.</li></ul><p>相见恨晚啊，这不就是我一直想要的嘛.. 天猫Nuvoton旗舰店一查价格：NUC505DL13Y（2MB SPI FLASH）才￥7.60！便宜的令人发指！！！  那还等什么？立马画板打板，开启了我的“坑”中之旅~~</p><p>先记录下官网用到的软件及文档：</p><ul><li>BSP：NUC505_Series_BSP_CMSIS_V3.03.001.zip</li><li>MDK Pack：Nuvoton.NuMicro_DFP.1.3.5.pack</li></ul><h3 id="坑一：J-Link不支持？"><a href="#坑一：J-Link不支持？" class="headerlink" title="坑一：J-Link不支持？"></a>坑一：J-Link不支持？</h3><p>明明是CortexM4核，明明也支持SWD模式，结果JLink无法识别，打开J-Link commander也没NUC505系列，估计是没给Segger付费吧，可惜了我的MiniJlink和RTT，好用的工具只能暂时放一边了，好在之前参加过几次Nuvoton的研讨会，大方的新塘送的demo板上都有NuLinkMe调试器，暴力掰下来，然后杜邦线连之。</p><p><img src="../../../../medias/boardPic/2020/NDemo.jpg" alt="Nuvoton Demo Board"></p><h3 id="坑二：片内SPI-Flash-And-Boot"><a href="#坑二：片内SPI-Flash-And-Boot" class="headerlink" title="坑二：片内SPI Flash And Boot"></a>坑二：片内SPI Flash And Boot</h3><p>前面多次提到过2MB的片内SPI Flash，2MB看上去很美，但是封的是SPI FLash，虽然支持片上运行，但是速度相比SRAM中运行慢了100倍！没错，是100倍！星爷的那句 “我奶奶骂他欺善民，反被他捉进了<strong>唐府</strong>，xx了一百遍 ！一百遍！！！” 在耳边飘荡…， Github中看到了下面的描述：</p><blockquote><p><em>“ Although code can run directly out of the SPI flash, <strong>execution is understandably SLOOOW</strong>. For this reason, the default Section Placement setting provided for new projects by this package is “Flash Copy to RAM”; however, the usual “Flash” and “RAM” options are provided for completeness as well.</em></p><p><em>The NUC505 has a “Boot from USB” mode where the device appears <strong>as a USB Mass Storage device. A .bin binary image copied to the device is programmed to the internal SPI memory at 0x0.</strong> When the NUC505 is then returned to the “Boot from Internal MCP SPI flash” and restarted, it will attempt to boot from that image. HOWEVER, the “Boot from USB” USB Mass Storage implementation appears to only work in Windows; Linux detects the emulated volume as having corruption and will refuse to mount it for write access.</em></p><p><em>When the NUC505 is set to its “<strong>SWD/ICE Mode with Internal SPI Flash</strong>“ mode, <strong>the NUC505 will NOT execute user code upon hardware reset.</strong> Instead, it runs from its internal mask ROM code and execution eventually reaches an endless loop. This boot mode seems to be intended exclusively for using an IDE to both program memory and specifically initiate debugging execution of the user application.”</em></p></blockquote><p>片上的spi flash看来只能用于代码的存储和boot了，（还可以用于存储一些数据，省了外部的存储了）然后将代码copy到ram里运行，也行，谁让它便宜来，128KB SRAM，分了4个bank，每个32KB，这样就可以作为<u>32K RAM/96 K Flash</u> 或者 <u>64K RAM/64 K Flash</u>的配置来用了，紧着这128K 来回蹂躏吧~</p><p>But，在“SWD/ICE with Internal SPI Flash”模式下无法运行用户代码是什么鬼？尝试了才知道：在这种模式下，可以通过MDK的debug进行程序下载、debug、查看变量、全速运行等等，但是退出debug模式，这货就不跑了！即使按reset也不行，想让它从能从spi flash中自举运行？那得改变它的硬件boot模式才行！只有1111模式下可以直接从内部SPI Flash启动，但是<strong>在这种模式下，仿真器无法连接！！！</strong>真是反人类的设计！！不服？咬他？当心被捉进<strong>唐府</strong>…</p><p>记NUC505的启动配置：（在复位时默认上拉，所以如需配置为0，则相应管脚需加10KR电阻下拉）</p><table><thead><tr><th align="center">PB.4</th><th align="center">PB.3</th><th align="center">PA.10</th><th align="center">PA.9</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td><td align="center"><strong>1</strong></td><td align="center"><strong>内部MCP SPI FLash启动</strong></td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center"><font color=#FF3300>0</font></td><td align="center"><strong>USB启动</strong></td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">外部SPI Flash启动</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">ICP模式启动</td></tr><tr><td align="center"><font color=#FF3300>0</font></td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center"><strong>SWD/ICE + 内部SPI Flash</strong></td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">SWD/ICE + 外部SPI Flash</td></tr></tbody></table><p>记录我的板子上的调试：</p><ul><li>电阻全都不焊，默认 1111 ： 从片上SPI Flash中启动</li><li><strong>R13 = 10KR， PB4=0， SWD/ICE + 内部SPI Flash ，调试时使用这种模式。</strong></li><li>R3 = 10KR， PA9=0， USB启动。</li></ul><h3 id="坑三：优化精简代码"><a href="#坑三：优化精简代码" class="headerlink" title="坑三：优化精简代码"></a>坑三：优化精简代码</h3><p>官方代码：NUC505_Series_BSP_CMSIS_V3.03.001，压缩包52M左右，解压后先看下Readme.pdf，比较详细的描述了各个目录下的工程等，为了方便备份，我又完整的拷贝了一份解压后的文件，打开NUC505_Series_BSP_CMSIS_V3.03.001\SampleCode\StdDriver\USBD_VCOM_SerialEmulator这个工程，然后开始编译+删除，不断尝试后把不需要用到的都给删除掉并能编译成功，至文件夹大约5MB左右，OK！这就是我要的工程了，以后就在这个上面盖房子就行。</p><p>注：默认配置该工程是使用的SPI FLASH的，需要先设置成“<strong>SWD/ICE + 内部SPI Flash</strong>”模式下，debug下可以运行，也可以下载，然后把启动模式更改为“<strong>内部MCP SPI FLash启动</strong>”，上电即可运行。</p><p>在SampleCode\BootTemplate下有几个例程，参考来实现如何使用SPI Flash和SRAM，目前使用MainOnSram例程，就是启动代码在spi flash中，然后其他大部分程序都是在ram中执行。直接用该例程的ld文件就可以。另外程序稍作配置，将主频配到180M，96M太对不起这内存了。顺便移植了下新塘的NuConsole，跟Segger的RTT类似，在debug模式下打开即可，再插上shell的翅膀，可以起飞啦！</p><p><img src="../../../../medias/boardPic/2020/NuConsole.png" alt="NuConsole"></p><p>顺便再吐槽下他家的NuConsole，虽然功能跟RTT相似，结果请看上图：不支持最大化！只能这么小窗口显示，真是小气的很~</p><h3 id="坑四：新鲜出炉的M484-NUC505"><a href="#坑四：新鲜出炉的M484-NUC505" class="headerlink" title="坑四：新鲜出炉的M484+NUC505"></a>坑四：新鲜出炉的M484+NUC505</h3><p>之前由于封装画错了的M484只能含泪默默重新改版，顺便把NUC505也改了改，加上了oled和按键。</p><p><img src="../../../../medias/boardPic/2020/M484Nuc505.jpg" alt="M484Nuc505"></p><p>NUC505 LQFP封装的可用IO 还是比较少的，目前几乎全用上了，于是在按键输入上又掉坑里了！</p><p>PA0 - 看上去是GPIO管脚，结果该脚使能上拉读出来的值始终为0，查了下手册才发现PA0-ADC_CH0，<strong>内建10KR电阻分压用作电池检测</strong>！内贱啊！！！也没个电路看看如果要测电池电压该怎么接…顺便看了下它的ADC，虽然只有一个ADC，可是玩出了很多花样：</p><ul><li><p>ADC_CH1通道最高可达1MSPS的采样率。</p></li><li><p>ADC_CH2~ADC_CH7:最高200KSPS采样率。</p></li><li><p>ADC_CH2：支持键盘比较器。</p></li><li><p>ADC_CH0：内建10KR电阻分压用作电池检测。</p></li></ul><p>好在OLED一把就点亮了，SPI代码配置真是简洁。</p><h3 id="坑五：VCP-512整数倍发送的问题"><a href="#坑五：VCP-512整数倍发送的问题" class="headerlink" title="坑五：VCP 512整数倍发送的问题"></a>坑五：VCP 512整数倍发送的问题</h3><p>老生常谈的话题了，早在STM32上就有这问题，结果在505上又遇到了，说白了就是在发完整数倍数据包如果还有要发的数据就接着发数据，没有要发的数据了就发个空包就行，在这一点上Nuvoton设计的还是比较人性化的：<br><code>USBD-&gt;EP[EPA].EPRSPCTL = USB_EP_RSPCTL_ZEROLEN;</code><br>对EPRSPCTL的ZERO位置1就会发送一个空包了。至于为啥是512，因为是高速USB嘛，还有一点：可以配置缓冲区为1024，然后收发 一包就是1024Byte，真爽~</p><h3 id="坑六：UART的接收超时中断"><a href="#坑六：UART的接收超时中断" class="headerlink" title="坑六：UART的接收超时中断"></a>坑六：UART的接收超时中断</h3><p>之前用stm32F072时使用串口空闲中断作为接收成帧判断，看NUC505的手册看到UART_TOUT寄存器中的TOIC：当RX FIFO接收到一个新的数据时，定时溢出计数器开始计数，超时后如果RXTOINT为使能，则接收超时中断RXTOINT产生。要求设置为40~255之间，如TOIC为40，则在4个字符时间长度后还没收到新数据，则超时中断产生。看这个描述正正合我的心意！UART1设置46字节fifo的阈值中断，这样使用也可以很大的减轻CPU的负担又能再收到一帧数据后 延时4个字符给出中断，测试时也是OK的，蛋蛋蛋但是：</p><p>当正好发送46字节时，则无超时中断产生，只有UART_INTSTS_RDAINT_Msk中断产生，从此读出数据后，UART_INTSTS_RXTOINT_Msk并未置位，而无论少一个或多一个，都是OK的！</p><p>what’s the ~！M48x的用户别偷笑，你们也有同样的问题！</p><p>查看UART_INTSTS寄存器中<strong>RXTOINT：如果TOUTIEN和RXTOIF都被置1，该位置1.</strong> 跟着看<strong>RXTOIF</strong>的描述：</p><p><strong>当RX FIFO非空且RX FIFO无活动发生，定时溢出计数器等于TOIC时，该位置位</strong>。</p><p>总和之即：超时中断要产生，需要RX FIFO非空，并且TOIC超时溢出并使能。那么问题就在于当正好到RX FIFO阈值中断时，在中断服务函数把数据全都读出来了导致RX FIFO空了，所以就不满足了，自然就无法产生超时溢出中断了！真是蛋疼的设计，那怎么解决呢？解决方法很简单，在阈值中断中让rx fifo不空就完事了。<strong>留一个字节在fifo里！</strong>问题完美解决！</p><p>顺便再吐槽一下：UART0的RX和TX FIFO是16， UART1和UART2的RX TX FIFO是64！就三个UART还整的不一样，顺便赞一下：RS485模式，使用RTS控制485的换向端，真香！</p><h3 id="坑七：NuLink-VS-JLink"><a href="#坑七：NuLink-VS-JLink" class="headerlink" title="坑七：NuLink VS JLink"></a>坑七：<del>NuLink</del> VS <strong>JLink</strong></h3><p>忍受了这么久的NULink，现在终于可以用JLink来欢快的仿真下载调试NUC505了，爽的不要不要的，实现方式很简单，就是在<strong>JLinkDevices.xml</strong>中添加上NUC505的型号就可以了，如下：</p><pre><code>&lt;Device&gt;    &lt;ChipInfo Vendor=&quot;Nuvoton&quot; Name=&quot;NUC505YO13Y&quot; WorkRAMAddr=&quot;0x20000000&quot; WorkRAMSize=&quot;0x00020000&quot; Core=&quot;JLINK_CORE_CORTEX_M4&quot; Aliases=&quot;NUC505DL13Y; NUC505DS13Y&quot;/&gt;    &lt;FlashBankInfo Name=&quot;SPI Flash&quot; BaseAddr=&quot;0x00000000&quot; MaxSize=&quot;0x00200000&quot; Loader=&quot;Devices/Nuvoton/NUC505_SPIFLASH.FLM&quot; LoaderType=&quot;FLASH_ALGO_TYPE_OPEN&quot; /&gt;&lt;/Device&gt;</code></pre><p>然后从keil目录下找到NUC505_SPIFLASH.FLM拷贝到 .\SEGGER\JLink\Devices\Nuvoton目录下即可，就能成功的读到芯片的ID。剩下的跟普通的仿真调试一样了。</p><p>顺便记一下解决仿真时弹出Verification 的ERROR:</p><p><img src="../../../../medias/boardPic/2020/debugError.png" alt="Verification of application image failed."></p><p>先看下下面的 “Download to flash” 是否√了。</p><p><img src="../../../../medias/boardPic/2020/checkDownloadFlash.png" alt="checkDownloadFlash."></p>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NUC505 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyStm32 - MiniFlasher</title>
      <link href="/2020/02/09/F072MiniFlasher/"/>
      <url>/2020/02/09/F072MiniFlasher/</url>
      
        <content type="html"><![CDATA[<p>使用STM32F072做了一个离线下载器，麻雀虽小然五脏俱全:</p><ul><li>MCU + 8/16 MB SPI Flasher.</li><li>0.96寸 128*64 OLED.</li><li>锂电池充放电管理.</li><li>一键开关机.</li><li>蜂鸣器指示（烧录完成后有提示音）.</li><li>穿上了衣服，有透明外壳.</li></ul><h3 id="Picture"><a href="#Picture" class="headerlink" title="Picture"></a>Picture</h3><p><img src="https://s2.ax1x.com/2020/02/10/14Grmn.jpg" alt="Stm32F072 MiniFlasher"></p><h3 id="离线烧录"><a href="#离线烧录" class="headerlink" title="离线烧录"></a>离线烧录</h3><p>参考移植了DAPLink的代码，烧写速度还是很快的。</p><p>通过MOS管控制对外供电，这样可以在烧写时打开供电，烧录完成后断开供电，可以热插拔了<del>~</del></p><h3 id="SPI-FLash-LittleFS"><a href="#SPI-FLash-LittleFS" class="headerlink" title="SPI FLash - LittleFS"></a>SPI FLash - LittleFS</h3><p>对这个文件系统还是很期待的，好在现在有了<strong>LittleFS Explorer (LFSE) for Windows</strong>工具 ，可以一试。</p><h3 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h3><p>哪有什么GUI啊，128 * 64 / 8，内存中做了个对应显存，然后全靠画点操作了，速度还是非常非常的快的，加了一个进度条用于烧写进度指示。</p><p>按键支持短按、长按，对于PWR键支持长按关机。</p><p>等有时间了再整理代码吧<del>~</del></p>]]></content>
      
      
      <categories>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> STM32F072 </tag>
            
            <tag> Flasher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/01/01/HelloHexo/"/>
      <url>/2020/01/01/HelloHexo/</url>
      
        <content type="html"><![CDATA[<p>Welcome to Hexo  ! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><ol><li>Download and install Git and node, node version : v12.16.0</li><li>test for node and npm, and install hexo.<pre class=" language-bash"><code class="language-bash">$ node -v$ <span class="token function">npm</span> -v$ <span class="token function">npm</span> <span class="token function">install</span> -g hexo</code></pre></li><li>Config git :<pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config --global user.name <span class="token string">"xxx"</span>$ <span class="token function">git</span> config --global user.email <span class="token string">"xxx@xxx.com"</span></code></pre></li><li>如果需要更换git地址或用户等，需要从windows中删除，按如下操作：<br> （1）：进入控制面板<br> （2）：选择用户账户<br> （3）：选择管理你的凭据<br> （4）：选择Windows凭据<br> （5）：选择git保存的用户信息<br> （6）：选择编辑或者进行删除操作<br> （7）：完成</li></ol><h3 id="One-Key-for-test"><a href="#One-Key-for-test" class="headerlink" title="One Key for test"></a>One Key for test</h3><pre class=" language-bash"><code class="language-bash">$ hexo clean <span class="token operator">&amp;</span> hexo g <span class="token operator">&amp;</span> hexo s</code></pre><h3 id="One-Key-for-publish"><a href="#One-Key-for-publish" class="headerlink" title="One Key for publish"></a>One Key for publish</h3><pre class=" language-bash"><code class="language-bash">$ hexo clean <span class="token operator">&amp;</span> hexo g <span class="token operator">&amp;</span> hexo d</code></pre><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="git链接码云仓库报错！连接不到服务"><a href="#git链接码云仓库报错！连接不到服务" class="headerlink" title="git链接码云仓库报错！连接不到服务"></a>git链接码云仓库报错！连接不到服务</h3><p>fatal: unable to access ‘<a href="https://gitee.com/.......&#39;" target="_blank" rel="noopener">https://gitee.com/.......&#39;</a>: Couldn’t connect to server，Failed to connect to gitee.com.port 443:Timed out</p><p>解决方案：</p><p>1.以管理员身份运行中输入cmd。</p><p>2.然后输入命令 netsh winsock reset。</p><p>3.重启计算机。</p>]]></content>
      
      
      <categories>
          
          <category> GIT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
